{"meta":{"title":"Eric's Blog","subtitle":null,"description":null,"author":"Eric","url":"http://yoursite.com"},"pages":[{"title":"IT IS ERIC！","date":"2018-05-31T12:33:30.000Z","updated":"2018-05-31T13:38:32.081Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"大家好！我是Eric，如果对我的文章有什么意见或者建议，请一定告知我~"}],"posts":[{"title":"用Flow进行静态类型检查","slug":"用Flow进行静态类型检查","date":"2018-07-02T13:20:12.000Z","updated":"2018-07-02T14:47:24.513Z","comments":true,"path":"2018/07/02/用Flow进行静态类型检查/","link":"","permalink":"http://yoursite.com/2018/07/02/用Flow进行静态类型检查/","excerpt":"","text":"用Flow进行静态类型检查为什么要静态类型检查JavaScript是一门非常灵活的弱类型语言，这是它的优点也是它的缺点。在声明变量之后通常可以随意更改该变量的数据类型，因此常常会导致出现那些在编译阶段没有报错，但是在执行时发生各种各样奇怪现象的BUG 。这时候就需要引入类型检查，使得在代码编译阶段就能发现隐患 。同时为了不影响代码运行时的性能，相比动态类型检查，我们更愿意选择静态类型检查。而Flow就是一个很好的选择。 Flow是什么Flow是由Facebook出品的JavaScript静态类型检查工具。单论类型检查，我们还可以选择TypeScript，但是对于一个需要添加添加静态类型检查的项目来说，使用TypeScript意味着需要重构整个项目 ，成本太高。所以对比之下，在这种情境，Flow一定是一个更好的选择。 Flow的使用示例12345function foo(x) &#123; return x + 10&#125;foo('Hello!') 以上代码中，foo函数预期接受的参数是一个数字，而返回的结果也应该是number类型的，但是却出现了传入字符串参数返回字符串参数却并没有报错的情况（当然会这样，因为JavaScript是弱类型语言啊）。这就偏离了我们的期望，可以利用Flow来进行改写： 1234567// @flowfunction foo(x: number): number &#123; return x + 10&#125;foo('hi') 以上代码限制了参数x的类型为number，并且函数的返回值类型也为number，要是两者中有任何一者没有达到预期的值，那么Flow就会报错。 如何使用Flow① 安装了flow之后，在项目根目录运行一下代码： 1flow init 该代码会在当前目录生成一个.flowconfig 文件用以配置。 ② 在代码的最上面一行加入以下注释： 1// @flow 或者是： 1/* @flow */ ③ 接下来我们可以利用各个ide中的插件来进行flow检查，或者也可以运行以下代码进行检查： 1flow check ④ 除此之外，我们还需要在编译的时候去除我们添加上去的/* @flow */ 注释，这就通常需要babel 的帮助。我们先要安装babel的一个插件babel-plugin-transform-flow-strip-types ，然后在.babelrc 文件中添加以下配置： 12345&#123; \"plugins\": [ \"transform-flow-strip-types\" ]&#125; 这样以后，之后再babel进行编译时就会一并转换Flow标记。 Flow支持的数据类型基础类型检测Flow.js中定义了五种基础数据类型（其中void类型对应JavaScript中的undefined）： boolean number string null void 所有的类型都可以使用垂直线符号| 来达到OR的效果，例如string | number 指的是string类型或者number类型。同时我们还可以使用可选类型 。可选类型通过在类型前加上？ 来表示该变量的值可能并不存在（为null或者undefined）： 123let num: number = 1;let str: string = 'a';let bar: ?string = null; 复杂类型检测Flow.js中还定义了一些复杂数据类型（注意：与基础类型不同，它们都为大写！）： Object： 12345let obj: Object = &#123; hello:'h'&#125;;//也可以这样定义let object: &#123;foo: string, bar: number&#125; = &#123;foo: \"foo\", bar: 0&#125;; Array： 数组类型使用的是Array&lt;T&gt;，例如Array&lt;number&gt;，会限定数组中的值只能使用数字的数据类型。当然你也可以加入垂直线|来定义允许多种类型，例如Array&lt;number|string&gt;。 123let numberArr: Array&lt;number&gt; = [12,3,2,3];//也可以用以下写法let numberArr: number[] = [12,3,2,3]; 函数 对于函数来说，我们通常只要求参数类型以及返回类型： 123456function fn(arg: number,arg2: string): Object &#123; return &#123; arg, arg2 &#125;&#125; 特殊的类型检测除了以上所说的类型检测，还有一个名为字面文字类型的检测。字面文字类型指的是以真实值作为数据类型，可用的值有三种，即数字、字符串或布尔值： 1234567891011121314151617type Suit = | \"Diamonds\" | \"Clubs\" | \"Hearts\" | \"Spades\";type Rank = | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | \"Jack\" | \"Queen\" | \"King\" | \"Ace\";type Card = &#123; suit: Suit, rank: Rank,&#125; 同时，我们还可以使用类型别名来预先定义和集中代码中所需要的类型： 123456789101112131415type T = Array&lt;string&gt;let x: T = []x[\"Hi\"] = 2 //有Flow警告//我们可以利用export导出预先定义好的类型，例如：export type NavigationRoute = &#123; key: string, title?: string&#125;;export type NavigationState = &#123; index: number, routes: Array&lt;NavigationRoute&gt;,&#125;; 参考这篇文章参考了一下文章： Flow静态类型检查及在Vue项目中的使用 Flow - JS静态类型检查工具 用flow.js提升前端开发的体验 学习Flow的基本用法是为了阅读vue源码打基础，有关Flow.js的深入以及细节问题请查阅官方文档。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"你不知道的JavaScript读书笔记(3)","slug":"UDKjs(3)","date":"2018-06-24T14:40:30.000Z","updated":"2018-06-24T14:40:35.199Z","comments":true,"path":"2018/06/24/UDKjs(3)/","link":"","permalink":"http://yoursite.com/2018/06/24/UDKjs(3)/","excerpt":"","text":"你不知道的JavaScript读书笔记(3)this全面解析不同于词法作用域在声明时就已经确定，this是在运行时进行绑定的。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 绑定规则想要得出this所绑定的对象，我们需要两步： 找到函数的调用位置； 判断应用以下四条规则中的哪一条； 默认绑定12345function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); //2 上例调用时就应用了this的默认绑定 ，因此this指向全局变量。那么我们如何得知此处应用了默认绑定呢？ 我们首先观察函数的调用位置，可以发现foo()是直接使用不带任何修饰符的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 但是，需要注意的是如果foo()运行在严格模式下（若是在严格模式下被调用则不受限制），那么就不能将全局变量用于默认绑定，因此this会绑定带undefined。例如： 123456function foo() &#123; \"use strict\"; console.log(this.a);&#125;var a = 2;foo(); //TypeError: this is undefined 隐式绑定另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含： 12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;obj.foo(); //2 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。 注意：对象属性引用链 中只有上一层或者说最后一层在调用位置中起作用： 123456789101112function foo() &#123; console.log( this.a );&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); //42 一个最常见的问题就是隐式丢失 ，即隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上。例如： 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = \"oops, global\";bar(); //\"oops, global\" 虽然bar是obj.foo的一个引用，但是实际上它引用的是foo函数本身，因此此时的bar()实际上是一个不带任何修饰的函数调用，因此应用了默认绑定。 一种更微妙，更常见并且更出乎意料的情况发生在传入回调函数时： 123456789101112function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn(); //此处为调用位置&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = \"oops, global\";doFoo(obj.foo); //\"oops, global\" 以上代码中向doFoo传入的参数虽然是obj.foo，但是实际上fn引用的是foo，所以结果就导致了应用默认绑定的规则。 显式绑定我们可以通过call()方法或者apply()方法来进行显式绑定，关于它们的用法可以参照我的另外一篇博客Call,aplly与bind。 注意：若你对这两种函数传入了一个原始值（字符串类型、布尔值类型或者数字类型）来当做this的绑定对象，这个原始值会被转换为它的对象形式。 可是，显式绑定仍然没有办法解决我们之前提出的问题绑定丢失的问题。要解决这个问题，可以使用显式绑定的一个变种——硬绑定。 12345678910111213function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;bar();setTimeout(bar, 100); //2//硬绑定的bar不可能再修改它的thisbar.call(window); 在以上代码中，我们创建了bar()，并且在它的内部手动调用foo.call(obj)，因此强制把foo的this绑定到了obj然后调用。 硬绑定的典型应用场景是创建一个可以重复使用的辅助函数（简易模拟bind函数）： 123456789101112131415function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;;&#125;var obj = &#123; a: 2&#125;;var bar = bind(foo, obj);var b = bar(3);//2 3console.log(b);//5 由于硬绑定非常常用，所以ES5提供了内置方法Function.prototype.bind。 new绑定要了解new绑定，我们首先要知道，每当你使用new构造一个对象时，发生了什么： 创建一个全新的对象； 这个新对象会被执行[[Prototype]] 连接； 这个新对象会绑定到函数调用的this ； 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 以下为new绑定的一个例子： 12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 优先级如果某个调用位置可以应用多条规则的话，它们应该靠优先级来决定this指向。 首先，默认绑定的优先级是四条规则中最低的。接着我们可以从以下代码来判断隐式绑定和显式绑定的优先级： 123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 2, foo: foo&#125;var obj2 = &#123; a: 3, foo: foo&#125;obj1.foo(); //2obj2.foo(); //3obj1.foo.call(obj2); //3obj2.foo.call(obj1); //2 由此可得，显式绑定的优先级高于隐式绑定。 那么new绑定和隐式绑定谁的优先级更高呢？ 123456789101112function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo(2);console.log(obj1.a);var bar = new obj1.foo(4);console.log(obj1.a); //2console.log(bar.a); //4 由以上代码可知：new绑定的优先级高于隐式绑定。 那么最后，new绑定和显式绑定谁的优先级高呢？ 12345678910function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);console.log(obj1.a); //2var baz = new bar(3);console.log(obj1.a); //2console.log(baz.a); //3 所以可以得出new绑定的优先级高于显式绑定。正如以上代码所得出的结论，在ES5中对于bind函数的实现中有一个细节是的这样：代码会判断硬绑定函数是否被new调用，如果是的话就会使用新创建的this替换硬绑定的this。之所以要在new中使用硬绑定的主要目的是预先设置函数的一些参数，这是柯里化的一种应用。有关柯里化，可以参考我之前的一篇博客：浅谈柯里化。 综上所述，这四种绑定规则的优先级是： new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 被忽略的this如果你把null或者undefined作为this的绑定对象传入call、apply或者bind中会怎么样呢？ 12345function foo() &#123; console.log(this.a);&#125;var a = 2;foo.call(null); //2 事实证明，这些值在调用时会被忽略，实际应用的是默认绑定规则。 箭头函数中的this箭头函数不使用this的四中标准规则，而是根据外层（函数或全局作用域）来决定this。我们来看一下以下代码： 12345678910111213function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); //2 以我个人的观点：箭头函数中的this 指向不是在调用时决定，而是在创建时就决定了（不知道是否正确…）。 让我们来分析一下上例都发生了什么： 首先声明了foo函数，然后该函数中的箭头函数的this指向了它的外层 ，也就是foo函数； 接着调用var bar = foo.call(obj1) 来将foo函数的this指向obj1 对象； 最后以bar.call(obj2) 来调用该箭头函数，意在将箭头函数的this绑定到obj2上，但是在创建时箭头函数的this已经指向了foo函数（并且foo函数中的this指向已经被修改为obj1了），所以再调用call函数时并不会修改结果，最后输出2。 对象类型在JavaScript中一共有六种主要类型： string number boolean null undefined object 其中object为复杂基本类型，而其余的类型都为简单基本类型 。而除了null和undefined之外，剩下三种简单基本类型都有对应的内置对象 。以下为内置对象的列表（注意都为大写字母开头）： String Number Boolean Object Function Array Date RegExp Error 这些内置对象从表现形式中很像其他语言中的类型(type)或者类(class)。但是在JavaScript中，它们实际上只是一些内置函数。而这些函数可以当做构造函数来使用，从而可以构造一个对应子类型的新对象。 但是在我们平常预见到额代码中，会出现以下情况： 123var str = \"i am a string\";console.log(str.length); //13console.log(str.charAt(3)) //\"m\" 此处的str明明只是一个简单基本类型string，为什么能够调用它的属性(length)和方法(charAt)呢？ 事实上，在必要时语言会自动把字符串(或者数字)字面量转换成一个String对象(或者Number对象)，并且在完成不要的操作后立即销毁。也就是说很多时候你并不需要显式地创建一个对象。 可计算属性名在对象中，属性名永远都是字符串。如果你使用string以外的其他值作为属性名，那么它首先会被转换为一个字符串。所以可以在数组中使用数组下标，但是在对象中最好不要这么做： 123456789var myObject = &#123;&#125;;myObject[true] = \"foo\";myObject[3] = \"bar\";myObject[myObject] = \"baz\";myObject[\"true\"]; //\"foo\"myObject[\"3\"]; //\"bar\"myObject[\"[object Object]\"]; //\"baz\" 同时需要注意的是：在ES6中增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当做属性名： 123456789var prefix = \"foo\";var myObject = &#123; [prefix + \"bar\"]: \"hello\", [prefix + \"baz\"]: \"world\"&#125;;myObject[\"foobar\"];//\"hello\"myObject[\"foobaz\"];//\"world\" 可计算属性名最常用的场景可能就是ES6中的Symbol ，它是一种新的基础数据类型，此处不做过多的说明。 数组数组具有下标，并且访问数组时，数组期望的是数值下标： 1234var myArray = [\"foo\", 42, \"bar\"];myArray.length;//3myArray[0];//\"foo\"myArray[2];//\"bar\" 但是需要注意的是，数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性 ： 1234var myArray = [\"foo\", 42, \"bar\"];myArray.baz = \"baz\";myArray.length;//3myArray.baz;//\"baz\" 可以看到，虽然添加了命名属性（无论是通过.语法还是[]语法），数组的length值都没有发生变化。但是需要注意的是：如果你试图向数组添加一个属性，但是属性名“看起来”像是一个数字，那么他会变成一个数组下标： 1234var myArray = [\"foo\", 42, \"bar\"];myArray[\"3\"] = \"baz\";myArray.length;//4myArray[3];//\"baz\" 复制对象在JavaScript 中应该如何复制一个对象呢？ 首先，我们需要决定是要进行浅复制还是进行深复制 。这两者的区别是浅复制对于目标对象中嵌套的对象，实际上进行的是复制该嵌套对象的引用 ，而深复制将会重新创建一个与之相等的对象。（需要注意深复制中的循环引用问题） ES6中定义了一个Object.assign() 方法，用于进行浅复制 。该方法的第一个参数是目标对象，之后可以跟一个或者多个源对象。它会遍历它们的所有可枚举的自有键，并把它们复制到目标对象（使用=赋值），最后返回目标对象： 1var newObj = Object.assign(&#123;&#125;, myObject, yourObject); 需要注意的是：由于Object.assign()是使用=操作符来赋值，所以源对象属性的一些特性（比如writable）就不会被复制到目标对象。 属性描述符从ES5开始，所有的属性都具备了属性描述符。 我们可以使用Object.defineProperty() 来添加一个属性，或者是修改一个已有属性（前提是它的configurable属性描述符的值为true ）并对特性进行设置。 1234567891011121314var myObject = &#123;&#125;;Object.defineProperty( myObject, \"a\", &#123; //为该属性赋值 value: 2, //可写入 writable: true, //可配置 configurable: true, //可枚举 enumerable: true&#125; );myObject.a; //2 其中： 你可以把writable:false 看做是属性不可改变，相当于你定义了一个空操作setter ； 而若configurable:false则表示不可配置属性标识符。注意：将configurable设置为false是单向操作，不可修改。（而且将不允许删除这个属性） 不变性有时候你会希望属性或者对象是不可改变的，在ES5中可以通过很多种方法来实现。但是需要注意的是：所有的方法创建的都是浅不变形 ，也就是说它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组、对象、函数等），其他对象的内容不受影响，仍然是可以改变的： 123myImmutableObject.foo; //[1, 2, 3];myImmutableObject.foo.push(4);myImmutableObject.foo; //[1, 2, 3, 4]; 如果为了保护foo，需要使用其他方法让foo也不可变。 对象常量结合writable:false和configurable:false就可以创建一个真正地常量属性（不可修改、重定义或者删除）。 123456var myObject = &#123;&#125;;Object.defineProperty(myObject, \"FAVORITE_NUMBER\", &#123; value: 42, writable: false, configurable: false&#125;); 禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions()： 123456var myObject = &#123; a: 2&#125;;Object.preventExtensions(myObject);myObject.b = 3;myObject.b; //undefined 密封Object.seal() 会创建一个密封的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions()并把所有现有属性标记为configurable:false 。 所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（不过可以修改现有属性的值）。 冻结Object.freeze()会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal()，并且把所有属性标记为writable:false，是你可以应用在对象上的级别最高的不可变性。 [[Get]]有如下代码： 1234var myObject = &#123; a: 2&#125;;myObject.a; //2 其中，myObject.a是一次属性访问，但是这条语句并不仅仅是在myObject中查找名为a的属性。myObject.a在myObject上实际上是实现了[[Get]]操作（类似于调用函数[[Get]]() 。如果无论如何都没有找到名称相同的属性，那么[[Get]]操作将会返回值undefined ： 1234var myObject = &#123; a: 2&#125;;myObject.b; //undefined 此处需要注意两点： 仅通过返回值，你无法判断一个属性是存在的（值为undefined），还是变量不存在； 这种方法和访问变量时不同。如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回undefined，而是会抛出一个ReferenceError异常。 Getter和Setter在ES5中可以使用getter和setter部分改写某个属性的默认操作。例如： 12345678910111213141516171819var myObject = &#123; get a() &#123; return 2; &#125;&#125;;Object.defineProperty( myObject, \"b\", &#123; get： function() &#123; return this.a * 2; &#125;, enumerable：true &#125;)；myObject.a; //2myObject.b; //4 不管是对象文字语法中的get a() {..}，还是defineProperty(..)中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值。 1234567var myObject = &#123; get a() &#123; return 2; &#125;&#125;;myObject.a = 3;myObject.a; //2 由于我们只定义了a的getter，所以对a的值进行设置时set操作会忽略赋值操作。我们可以这样设置： 12345678var myObject = &#123; get a() &#123; return this._a_; &#125;, set a(val) &#123; this._a_ = val * 2; &#125;&#125;; 存在性正如之前所说的，若是我们访问对象中的一个属性时，要是返回undefined ，那么我们这时候应该如何判断这个属性是存在的还是不存在？ 我们可以用in操作符： 12345678var myObject = &#123; a: 2&#125;;(\"a\" in myObject);// true(\"b\" in myObject);// falsemyObject.hasOwnProperty(\"a\"); //truemyObject.hasOwnProperty(\"b\"); //false 不过需要注意的是：in操作符会检查属性是否在对象及其[[Prototype]]原型链中。而hasOwnProperty() 只会检查属性是否在该对象中。 而不论属性的属性描述符的enumerable值是否为false ，in操作符和hasOwnProperty() 函数都会返回该属性 ，不同的是： propertyIsEnumerable()函数会检查给定的属性名是否直接存在于对象中，并且满足enumerable:true； Obejct.keys() 会返回一个数组，包含所有的可枚举属性； 而getOwnPropertyNames() 则会返回一个数组，包含所有属性，无论它们是否可枚举；","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅谈柯里化","slug":"柯里化","date":"2018-06-19T09:10:07.000Z","updated":"2018-06-19T09:19:40.307Z","comments":true,"path":"2018/06/19/柯里化/","link":"","permalink":"http://yoursite.com/2018/06/19/柯里化/","excerpt":"","text":"浅谈柯里化什么是柯里化柯里化也通常被称为部分求值 ，它的含义就是给函数分步传递参数，每次传入一部分参数后，返回一个更具体的函数接受剩下的参数。 因此，柯里化的过程是逐步传参，逐步缩小函数适用范围，逐步求解的过程。例如： 1234567891011121314function concat3words(a, b, c) &#123; return a + b + c;&#125;function concat3wordsCurrying(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125; &#125;&#125;console.log(concat3words('foo ', 'bar ', 'baz ')); //foo bar bazconsole.log(concat3wordsCurrying('foo')); //[Function]//链式调用console.log(concat3wordsCurrying('foo')('bar')('baz')); //foo bar baz 以上代码就是一个简单的柯里化的例子（利用了闭包的特性）。 考虑以下要求：可传递的参数不只三个，可以传递任意多个参数，当不传递参数时输出结果。 我们首先用普通的方法实现： 1234567891011121314//全局变量保存sumlet sum = 0;function add() &#123; if (arguments.length === 0) &#123; //不传递参数则输出并清空 console.log(sum); sum = 0; &#125; else &#123; //否则迭代相加 sum += [].reduce.call(arguments, function(a, b) &#123; return a + b; &#125;); &#125;&#125; 接着我们利用柯里化实现： 1234567891011121314151617181920//第一次调用adder将会初始化_args并且返回一个函数var adder = function () &#123; var _args = []; //接着每次为函数传参即可 //传参成功后返回add函数即可完成链式调用 return function add() &#123; if (arguments.length === 0) &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; _args.push.apply(_args, arguments); return add; &#125;&#125;; var sum = adder();sum(100, 200)(300);sum(400);//1000console.log(sum()) 通用的柯里化函数更典型的柯里化函数会具有一个函数参数，该函数会在柯里化函数的最后一步被调用。 接下来我们将上例的柯里化实现通用化： 1234567891011121314151617181920212223var adder = function (fn) &#123; var _args = []; return function add() &#123; if (arguments.length === 0) &#123; //最后一步的处理函数 return fn(_args); &#125; _args.push.apply(_args, arguments); return add; &#125;&#125;; function getSum(argus) &#123; return argus.reduce(function(a, b) &#123; return a + b; &#125;);&#125;var sum = adder(getSum);sum(100, 200)(300);sum(400);//1000console.log(sum()) 这样的代码调用看起来很清晰，同时支持链式调用。 柯里化函数的基础正如上面的通用柯里化函数所示，通用的柯里化函数其实是一个高阶函数（接受函数作为参数的函数）。通用的柯里化函数有以下几个特点： 函数作为参数传递（即为高阶函数）； 函数能够作为该函数的返回值； 返回的函数具有闭包并且可以被充分利用； 柯里化的作用 延迟计算：正如以上例子展示的迭代相加； 参数复用：当你多次调用一个函数，并且有很多传递的参数都是重复的，那么就可以考虑将其柯里化； 动态创建函数：例如： 以下函数的作用是根据判断不同的浏览器，进行事件绑定。 1234567891011var addEvent = function(el, type, fn, capture) &#123; if (window.addEventListener) &#123; el.addEventListener(type, function(e) &#123; fn.call(el, e); &#125;, capture); &#125; else if (window.attachEvent) &#123; el.attachEvent(\"on\" + type, function(e) &#123; fn.call(el, e); &#125;); &#125; &#125;; 但是以上代码的缺点就是每次绑定事件都需要进行一次if...else...判断（明明是只要判断一次就足够了）。因此我们可以将其柯里化： 123456789101112131415var addEvent = (function()&#123; if (window.addEventListener) &#123; return function(el, sType, fn, capture) &#123; el.addEventListener(sType, function(e) &#123; fn.call(el, e); &#125;, (capture)); &#125;; &#125; else if (window.attachEvent) &#123; return function(el, sType, fn, capture) &#123; el.attachEvent(\"on\" + sType, function(e) &#123; fn.call(el, e); &#125;); &#125;; &#125;&#125;)(); //柯里化函数立即执行 需要注意的是，其实ES5中的bind 的实现就是利用了柯里化（这也是为什么已经被bind硬绑定的函数不能再通过call或apply修改执行上下文的原因），这里不展开叙述。 小结在对柯里化有了一些基本的了解之后，我对柯里化函数的个人理解就是：一个能够简化（包括减少参数或者多余的逻辑判断等）并且返回简化后函数的函数。 如果对文章内容有所疑惑可以联系我或查看下列参考文章。 本文参考：浅析 JavaScript 中的 函数 currying 柯里化 ；","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"你不知道的JavaScript读书笔记(2)","slug":"UDKjs(2)","date":"2018-06-18T12:33:30.000Z","updated":"2018-06-18T10:55:08.146Z","comments":true,"path":"2018/06/18/UDKjs(2)/","link":"","permalink":"http://yoursite.com/2018/06/18/UDKjs(2)/","excerpt":"","text":"你不知道的JavaScript读书笔记(2)提升编译器在提升中起到了很重要的作用。因为编译阶段的一部分工作就是找到所有的声明，并且用合适的作用域将它们关联起来。例如： 123//输出undefinedconsole.log(a);var a = 2; 以上代码是可以运行的，它实际产生的效果如下： 12345//这一句声明在编译阶段就已经完成！var a;//以下代码在执行阶段才会完成console.log(a);a = 2; 函数声明和变量声明都会被提升，但是需要注意的是：函数会被首先提升，然后才是变量。例如： 12345678//输出1foo();var foo = function() &#123; console.log(2);&#125;;function foo() &#123; console.log(1);&#125; 在上述代码中，函数声明foo以及变量foo都被提升，但是由于函数声明先提升，并且JavaScript会忽略重复的var声明，所以foo()函数会输出1。 作用域闭包闭包的含义可以将闭包理解为函数所特有的一种属性 ，而这个属性的值就是该函数的原始作用域的引用。但不是所有的函数都具有这个属性，只有当函数能够记住并且访问所在词法作用域时（指能够在自己定义的词法作用域以外的地方执行），它才能产生闭包，并且不论何时何地执行会将会使用闭包（指引用的作用域）。 123456789function wait(message) &#123; //timer函数就具有闭包，因为它在1000毫秒后会在自己定义的词法作用域之外的地方执行 //并且保持着对原始作用域的引用 //当然这也会导致在这段时间内，无法销毁wait函数的内存 setTimeout( function timer() &#123; console.log(message); &#125;, 1000);&#125;wait(\"Hello, closure!\") 注意：任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。 循环和闭包12345for(var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000);&#125; 我们对以上代码的预期是每秒分别输出数字1~5。而实际上这段代码会以每秒一次的频率输出五次6。导致这样的结果的原因就是实际上只有一个i 在全局作用域中，所以每个函数引用的i都是同一个值。 要达到我们预期的结果，我们有以下解决思路： 可以发现每次输出同一个值的原因是因为所有timer 函数共享一个i ； 那为什么不使每个timer函数拥有自己独特的i ； 又因为timer函数具有闭包，访问的是原始作用域； 那么要使timer拥有自己独立的i，我们可以手动为setTimeout创建一个作用域，然后在此作用域中声明独特的i ； 1234567for(var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log(j); &#125;, i*1000); &#125;)(i)&#125; 同理也可以使用以下写法： 1234567for(var i = 1; i &lt;= 5; i++) &#123; //通过let关键字产生了块级作用域 let j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000);&#125; 或者： 12345678//for循环头部的let声明还会有一个特殊的行为//这个行为指出变量在循环的过程中不只被声明一次//所以每次都会得到预期的值for(let i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000);&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"你不知道的JavaScript读书笔记(1)","slug":"UDKjs(1)","date":"2018-06-17T12:33:30.000Z","updated":"2018-06-18T10:54:47.752Z","comments":true,"path":"2018/06/17/UDKjs(1)/","link":"","permalink":"http://yoursite.com/2018/06/17/UDKjs(1)/","excerpt":"","text":"你不知道的JavaScript读书笔记(1)作用域是什么编译原理大家通常把JavaScript 归类为“动态”或者是“解释执行”语言，但是事实上它是一门编译语言。但是它不是提前编译的，而是在每块代码执行前当场编译的。 首先进行词法分析将代码字符串分解为有意义的代码块，称为词法单元 ；然后进行语法分析将词法单元流转换为代表程序语法的树，称为抽象语法树AST(Abstract Syntax Tree) ；然后再进行代码生成，即把AST转换为一组机器指令。 引擎中的查找每当遇到一个变量，引擎都会进行LHS或者RHS 。其中当变量出现在赋值操作的左侧时（即获取变量的容器），进行LHS查询；而当变量出现在赋值操作的右侧时（即获取变量的值），进行RHS查询。 1234567function foo(a) &#123; //此处进行了一次RHS查询以获取a的值 console,log(a);&#125;//此处进行了一次RHS查询，以获取foo函数//接着将2作为参数传入，使得a=2，隐式地执行了一次LHS查询foo(2); 注意：将函数声明理解为LHS查询并不合适。 如果RHS查询在所有嵌套的作用域中都找不到所需变量，那么引擎就会抛出一个ReferenceError异常；而若LHS查询在所有嵌套的作用域中都找不到所需变量，那么就会在全局作用域下创建一个该变量并返回（非严格模式下）。 注意：若是在严格模式下也会抛出一个ReferenceError异常。 接下来，如果RHS成功查询到了一个变量，但是你尝试对变量进行不合理的操作，例如引用null类型中的属性，那么引擎会抛出另外一种类型的异常TypeError。 总的来说，ReferenceError和作用域判别失败有关，而TypeError表示作用域的判别成功了，但是对结果的操作是非法或者不合理的。 词法作用域词法作用域是由你在写代码时将变量和作用域写在哪里来决定的，因此大部分情况下，词法作用域分析处理代码时会保持作用域不变。 注意：全局变量会自动成为全局对象（例如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行引用（以防止遮蔽效应）。例如： 1window.a 同时，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法作用域词法作用域通常在声明时就已经确定，但是在JavaScript中有一些方法可以在执行时改变它（并不推荐使用）。 evalJavaScript中的eval函数可以接受一个字符串作为参数，并将其中的内容视为书写时就好像存在于程序中的这个位置的代码。 123456function foo(str, a) &#123; eval(str); console.log(a, b);&#125;var b = 2;foo(\"var b = 3;\", 1); 以上代码演示了eval是如何改变词法作用域的。 不过注意：严格模式下，eval函数有自己的词法作用域，所以将无法修改所在作用域。 还有一些其他功能效果和eval很相似的代码，例如： setTimeout和setInterval的第一个参数可以使字符创，字符串的内容可以被解释为一段动态生成的函数代码。 new Function()函数的最后一个参数可以接受代码字符串，并且将其转化为动态生成的函数。 withwith通常被当做重复引用一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。例如： 1234567891011var obj = &#123; a: 1, b: 2, c: 3&#125;;//便捷修改各个属性的值with(obj) &#123; a = 3; b = 4; c = 5;&#125; 而如下代码将会造成预料之外的效果： 12345678910111213141516171819function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo(o1);//输出2，o1.a被改变了console.log(01.a);foo(o2);//输出undefinedconsole.log(o2.a);//输出2，a被泄漏到全局作用域上了console.log(a); 其实，with块会将一个对象处理为词法作用域 （但是这个块内部正常var的变量不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中）。 让我们来理一下之前那段代码到底发生了什么： 当调用foo(o2)时，调用了with(o2) ，将这个对象变成了一个词法作用域（其中声明了b属性，值为3）； 接着调用a = 2 ，这时引擎将会执行一个LHS 查询，但是在with作用域，函数foo作用域与全局作用域中都没有找到a这个变量，那么此时将会声明一个全局变量a并且返回然后赋值； 最后执行console.log(o2)时输出了undefined（因为是在全局作用域中声明的）。 总结总的来说，eval函数如果接受了包含一个或多个声明的代码，就会修改其所在的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。 但是我们需要尽量避免使用它们，因为它们会大大降低代码运行的速度。因为在JavaScript引擎会在编译阶段进行数项的性能优化，其中就包括了词法分析时预先确定所有变量和函数定义的位置 ，这样才能在执行过程中快速找到标识符。而如果引擎在代码中发现了eval或with，那么它只能简单地假设关于标识符位置的判断是无效的（因为可能会被这二者修改，但是在词法分析阶段是无法得知的），这就会使得代码运行速度变慢。 函数作用域和块作用域函数中的作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用。 隐藏内部实现我们通常声明一个函数，在函数体里声明变量并且完成一些操作。这样做的结果就是外部无法轻易访问函数体内部的变量。那么只要我们转换一下想法，那么我们就可以：为了隔离作用域，使得某些代码块的变量无法被其他块所引用，我们可以将它们包裹在一个函数中。 函数作用域正如之前所说的，我们已经知道可以通过给任意代码片段外部添加包装函数，可以将内部的变量和函数定义给隐藏起来，使得外部作用域无法访问包装函数内部的任何内容。例如： 12345678var a = 2;function foo() &#123; var a = 3; console.log(a);&#125;foo();//输出2console.log(a); 虽然以上代码的确可以解决标识符之间的冲突，但是它会导致两个问题： 会对所在作用域进行变量污染（例子中foo这个函数名污染了全局作用域）； 我们必须要显式地通过函数名调用这个函数才能运行其中的代码； 作为改进，我们可以把以上代码重构为： 1234567var a = 2;(function foo() &#123; var a = 3; console.log(a);&#125;)();//输出2console.log(a); 以上代码通过将function foo() 包裹在()中来使得它成为函数表达式而非函数声明（若function是声明中的第一个词，那么这就是一个函数声明，否则它就是一个函数表达式），这将会导致函数没有被提升到作用域顶部，并且只能在函数体中使用自己的标识符。接着直接跟一对括号，来达到立即执行的目的。 注意：函数声明和函数表达式之间最重要的区别就是他们的名称标识符将会绑定在何处。 块作用域JavaScript 的ES5中并没有块作用域的功能，只能通过其他方法来达到实现块作用域。 with正如之前讨论过的，with语句可以创建一个词法作用域，所以它是实现块作用域的一个例子。 try/catch很少人会注意到其实JavaScript的ES3规范中规定try/catch中的catch分句会创建一个块作用域，其中声明的变量只在catch内部有效。 ES6我们可以使用ES6规范中的let与const 关键字来实块现生成块作用域的功能，具体用法此处不作抄录。需要注意的是块作用域之所以非常有用的原因和闭包以及回收内存垃圾的回收机制相关。例如： 123456789function process(data) &#123; //do something here&#125;var someReallyBigData = &#123; .. &#125;;process(someReallyBigData);var btn = document.getElementById(\"my_button\");btn.addEventListener(\"click\", function click(evt) &#123; console.log(\"button clicked\");&#125;, false); 以上代码中，btn的点击事件回调并不需要someReallyBigData 变量。理论上这意味着当process(..)执行完成后，再内存中占用大量空间的数据结构就可以被垃圾回收了。但是由于click函数形成了一个闭包，所以JavasScipt引擎极有可能依然保存着这个结构。 而块作用域可以打消这种顾虑，例如： 123456789101112function process(data) &#123; //do something here&#125;//这个块中定义的内容完事可以销毁！&#123; let someReallyBigData = &#123; .. &#125;; process(someReallyBigData);&#125;var btn = document.getElementById(\"my_button\");btn.addEventListener(\"click\", function click(evt) &#123; console.log(\"button clicked\");&#125;, false);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"利用rem进行适配","slug":"rem","date":"2018-05-30T12:33:30.000Z","updated":"2018-05-31T13:10:44.862Z","comments":true,"path":"2018/05/30/rem/","link":"","permalink":"http://yoursite.com/2018/05/30/rem/","excerpt":"","text":"利用rem进行适配rem作为一个长度单位，可以使得前端开发者很方便地在各种屏幕尺寸下，通过等比缩放的方式来适配。 定义rem的官方定义为The font size of the root element ，即为根节点的字体大小。一般认为网页中的根节点是html元素，所以采用的方式也是通过设置html元素的font-size来做屏幕是配的。 基础解决方案123456789101112131415161718(function(doc, win) &#123; //获取当前文档元素 var docEl = doc.documentElement, //判断是否有旋转功能 resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; //获取设备宽度 var clientWidth = docEl.clientWidth; if (!clientWidth) return; //设置根元素字体大小 docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if (!doc.addEventListener) return; //为相应事件添加监听函数 win.addEventListener(resizeEvt, recalc, false); //文档DOM节点载入完成后立即调用 doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window);","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML中的meta标签","slug":"meta","date":"2018-05-30T12:33:30.000Z","updated":"2018-05-31T13:06:46.306Z","comments":true,"path":"2018/05/30/meta/","link":"","permalink":"http://yoursite.com/2018/05/30/meta/","excerpt":"","text":"HTML中的meta标签简介元数据是用于描述数据的数据，也就是metadata 。它不会显示在页面上，但是机器却可以识别它。 作用meta 常常用于定义页面的说明、关键字、最后修改日期以及其他元数据。这些元数据将服务于浏览器、搜索引擎和其他网络服务。 组成meta标签一共有两个属性，分别是http-equiv以及name属性。 name属性name属性的主要作用是描述网页的相关信息，比如网页的关键词、叙述等。与之对应的属性值为content ，它之中的内容是对name填入类型的具体描述，有利于搜索引擎抓取。 meta标签中name属性语法格式是： 1&lt;meta name=\"参数\" content=\"具体的描述\"&gt;。 以下为几种name属性的常用值： 12345678910&lt;!-- 该网页的作者 --&gt;&lt;meta name=\"author\" content=\"Eric,ericy9707@foxmail.com\"&gt;&lt;!-- 该网页的关键词 --&gt;&lt;meta name=\"keywords\" content=\"Eric,博客，前端\"&gt;&lt;!-- 该网页内容的描述 --&gt;&lt;meta name=\"description\" content=\"这是Eric的博客\"&gt;&lt;!-- 版权 --&gt;&lt;meta name=\"copyright\" content=\"Eric\"&gt;&lt;!-- 视窗设置 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; http-equiv属性http-equiv属性的作用顾名思义，就是在HTML文档中可以设置部分HTTP请求头属性。 meta标签中http-equiv属性语法格式是： 1&lt;meta http-equiv=\"参数\" content=\"具体的描述\"&gt; 以下为几种http-equiv属性的常用值： 123456789101112&lt;!-- 设置网页字符集 --&gt;&lt;meta charset=\"utf-8\"&gt;&lt;!-- 告诉浏览器采用何种方式渲染页面 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt;&lt;!-- 指定缓存机制 --&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;!-- 禁止百度自动转码 --&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;!-- 设定重定向 --&gt;&lt;meta http-equiv=\"refresh\" content=\"2；URL=http://www.baidu.com/\"&gt;&lt;!-- 设置cookie --&gt;&lt;meta http-equiv=\"Set-Cookie\" content=\"User=Eric; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT\"&gt; viewport在了解viewport 之前，我们先需要明白的是，在地移动端中，css的1px并不等于物理意义上的1px ，因为手机屏幕的分辨率已经越来越高，像素越来越高，但是屏幕的尺寸却没有发生很大的变化，那就意味着物理上的1px其实已经远远不止1px了 。 在移动端浏览器以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它表示的是：设备物理像素（1px所包含的像素）和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。 需要注意的是，有一个因素将会引起css中px的变化，那就是用户缩放。如果把页面放大一倍，那么css中的1px所代表的的像素也会增加一倍。 所以在做移动端开发的时候，为了使移动端的页面在不同的手机上以同样的大小来显示，我们可以将页面的宽度固定，然后获取设备的宽度，可以得到我们之前设定的宽度与设备宽度的比例 ，然后我们再通过viewport来对页面进行缩放，直到这个比例值等于前文所说的devicePixelRatio ，并且固定不允许用户再重新缩放。 viewport的具体用法 属性名 备注 width 设置layout viewport的宽度，为一个正整数，使用字符串device-width表示设备宽度 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为no或yes, no 代表不允许，yes代表允许 其中： layout viewport 表示的是网页的整体宽高； visual viewport 表示的是设备的宽高； 小结","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"深入浅出webpack学习笔记","slug":"webpack","date":"2018-05-27T12:33:30.000Z","updated":"2018-05-31T13:18:44.112Z","comments":true,"path":"2018/05/27/webpack/","link":"","permalink":"http://yoursite.com/2018/05/27/webpack/","excerpt":"","text":"深入浅出webpack学习笔记Webpack 凭借强大的功能与良好的使用体验，已经成为目前最流行，社区最活跃的打包工具，是现代 Web 开发必须掌握的技能之一。 为什么要使用构建工具构建工具中的构建 其实是工程化、自动化思想在前端开发中的体现，让代码自动化地执行这一系列复杂的流程。它包括以下内容： 代码转换：将TypeScript编译为JavaScript，将SCSS编译为CSS等； 文件优化：压缩JavaScript、CSS、HTML代码，压缩合并图片等； 代码分割：提取多个页面的公共代码、提取首屏不需要执行的部分代码让其异步加载； 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并为一个文件； 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器； 代码校验：在代码被提交到仓库之前需要检验代码是否符合规范，以及单元测试是否通过； 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统； webpack安装与运行首先可以通过以下代码来初始化一个项目： 1npm init 接着可以本地安装webpack： 1npm install webpack --save-dev 运行时可以使用以下代码（本地安装）： 1\"node_modules/.bin/webpack\" 注意：在webpack看来，一切皆模块。 Loader由于我们应该在入口文件中添加依赖，所以当我们需要应用css 时，我们可以在入口文件中引入： 12require('./main.css');//若是不分离css，那么最后可以得到能够应用css的js脚本 若是这样直接去执行webpack构建将会报错，因为webpack不原生支持解析css文件。要支持非javascript类型的文件，需要使用Loader机制： 123456789101112131415161718192021const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ['style-loader', 'css-loader?minimize'], &#125; ] &#125;&#125;; 可以认为Loader 具有文件转换功能。而配置中的module.rules数组配置了一组规则，告诉 webpack在遇到哪些文件时使用哪些Loader去加载和转换。 需要注意的是： use属性的值是一个由Loader名称组成的数组，并且执行顺序是从后往前的； 每一个Loader都可以通过URL querystring的方式来传入参数，例如css-loader?minimize 表示需要开启css压缩； 上例中的css-loader 负责读取文件，再交给style-loader把css内容注入到javascript中。 其中style-loader 的原理大概是：把css内容用js中的字符创保存起来，在网页执行js脚本的时候通过dom操作动态地往HTML head标签插入HTML style标签。 给Loader传递参数的方法除了querystring之外，还可以通过object传入： 123456789use: [ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true, &#125; &#125;] 除了在webpack.config.js文件中配置Loader之外，还可以在源码中配置，例如： 12require('style-loader!css-loader?minimize!./main.css');//同时包含引入操作 PluginPlugin是用来扩展webpack功能的，通过在构建流程中注入钩子实现，它给webpack带来了很大的灵活性。例如： 12345678910111213141516171819202122232425262728293031const path = require('path');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 把输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; // 转换 .css 文件需要使用的 Loader use: ['css-loader'], &#125;), &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#123; // 从 .js 文件中提取出来的 .css 文件的名称 filename: `[name]_[contenthash:8].css`, &#125;), ]&#125;; 添加以上代码就可以把原本添加进js文件的css代码给分离出一个单独的css文件了。 可以看出，plugin属性是一个数组，里面的每一项都是插件的一个实例，你也可以在实例化的时候通过构造函数传入配置属性 ，例如本例指定了CSS输出的文件名。 DevServer在实际开发中你可能会需要： 提供HTTP服务而不是本地文件预览； 监听文件的变化并且自动刷新网页，做到实时预览； 支持Source Map，以方便调试； webpack原生支持后两点，并且利用官方提供的开发工具DevServer可以很方便地做到第一点。 DevServer会启动一个HTTP服务器用于服务网页请求，同时会帮助启动webpack , 并且接收webpack发出的文件变更信号，通过WebSocket协议自动刷新网页做到实时预览。 可以通过以下命令安装该模块： 1npm install webpack-dev-server --save-dev 启动之后，DevServer 启动的HTTP服务器就开始监听http://localhost:8080 了，通过访问这个网址就可以访问该目录下的index.html 。用浏览器打开这个地址你会发现页面空白错误原因是 ./dist/bundle.js 加载404了。 同时你会发现并没有文件输出到 dist 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。所以要获取 bundle.js的正确 URL 是 http://localhost:8080/bundle.js，对应的 index.html 应该修改为： 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!--导入 DevServer 输出的 JavaScript 文件--&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实时预览webpack在启动时可以开启监听模式，开启之后webpack会监听本地文件系统的变化，发生变化时重新构建出新的结果。webpack是默认是关闭监听模式的，你可以在启动webpack时通过以下命令开启监听： 1webpack --watch 通过DevServer启动的webpack会开启监听模式，当发生变化时重新构建完成然后通知DevServer 。 如果尝试修改index.html文件并保存，将不会触发实时更新，因为之后entry和entry所依赖的文件会被加入到监听列表中。 模块热替换除了通过刷新整个网页来实现实时预览，DevServer还有一种被称为模块热替换的刷新技术。模块热替换能够做到在不重新加载整个网页的情况下，通过新模块替换旧模块然后重新执行一次来实现实时预览。 模块热替换默认是关闭的，要开启模块热替换，只需要在启动DevServer时带上--hot参数即可。 支持Source Map在浏览器中运行的javascript代码都是编译器输出的代码，这些代码的可读性很差。如果在开发过程中遇到一个BUG，那么将会很难调试。调试工具可以通过Source Map映射代码，让你在源代码上断点调试。只要在启动webpack时带上参数--devtool source-map 。添加上参数后重启DevServer 即可。 核心概念webpack有以下几种核心概念： entry：入口，webpack执行构建的第一步将从ebtry开始； module：模块，在webpack里一切皆模块，一个模块对应着一个文件。webpack会从配置的entry开始递归地找出所有依赖的模块； Chunk ：代码块，一个chunk由多个模块组合而成，用于代码合并与分割； Loader：模块转换器，用于把模块原内容按需求转换为新内容； Plugin ：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情； Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 webpack启动后会从entry里配置的module递归找出所有依赖。每找到一个module，就会根据配置的loader进行对应的转换。这些module会以entry为单位进行分块，一个entry和它的所有依赖被分到一个块（也就是chunk）。最后webpack会把所有chunk转换为文件输出。在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 配置entryentry是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。 entry 配置是必填的，若不填则将导致 Webpack 报错退出。 entry类型Entry 类型可以是以下三种中的一种或者相互组合： 类型 例子 含义 string &#39;./app/entry&#39; 入口模块的文件路径，可以是相对路径。 array [&#39;./app/entry1&#39;, &#39;./app/entry2&#39;] 入口模块的文件路径，可以是相对路径。 object { a: &#39;./app/entry-a&#39;, b: [&#39;./app/entry-b1&#39;, &#39;./app/entry-b2&#39;]} 配置多个入口，每个入口生成一个 Chunk Chunk 名称Webpack 会为每个生成的 Chunk 取一个名称，Chunk 的名称和 Entry 的配置有关： 如果 entry 是一个 string 或 array，就只会生成一个 Chunk，这时 Chunk 的名称是 main； 如果 entry 是一个 object，就可能会出现多个 Chunk，这时 Chunk 的名称是 object 键值对里键的名称。 outputoutput 配置如何输出最终想要的代码。output 是一个 object，里面包含一系列配置项，下面分别介绍它们。 filenameoutput.filename 配置输出文件的名称，为string 类型。 如果只有一个输出文件，则可以把它写成静态不变的： 1filename: 'bundle.js' 但是在有多个 Chunk 要输出时，就需要借助模版和变量了。前面说到 Webpack 会为每个 Chunk取一个名称，可以根据 Chunk 的名称来区分输出的文件名： 1filename: '[name].js' 代码里的 [name] 代表用内置的 name 变量去替换[name]，这时你可以把它看作一个字符串模块函数， 每个要输出的 Chunk 都会通过这个函数去拼接出输出的文件名称。 内置变量除了 name 还包括： 变量名 含义 id Chunk 的唯一标识，从0开始 name Chunk 的名称 hash Chunk 的唯一标识的 Hash 值 chunkhash Chunk 内容的 Hash 值 其中 hash 和 chunkhash 的长度是可指定的，[hash:8] 代表取8位 Hash 值，默认是20位。 pathoutput.path 配置输出文件存放在本地的目录，必须是 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径： 1path: path.resolve(__dirname, 'dist_[hash]') publicPath在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的 URL 地址。 output.publicPath 配置发布到线上资源的 URL 前缀，为string 类型。 默认值是空字符串 &#39;&#39;，即使用相对路径。 举个例子，需要把构建出的资源文件上传到 CDN 服务上，以利于加快页面的打开速度。配置代码如下： 12filename:'[name]_[chunkhash:8].js'publicPath: 'https://cdn.example.com/assets/' 这时发布到线上的 HTML 在引入 JavaScript 文件时就需要： 1&lt;script src='https://cdn.example.com/assets/a_12345678.js'&gt;&lt;/script&gt; modulemodule配置如何处理模块。 配置loaderrules配置模块的读取和解析规则，通常都是用来配置Loader的。它的类型是一个数组，数组里每一项某描述了如何去处理部分文件。配置rules时大致通过以下方式： 条件匹配：通过test、include和exclude三个配置项来命中Loader要应用规则的文件； 应用规则：对选中的文件通过use配置项来应用loader（注意：loader应用顺序为从后往前）； 重置顺序：可以通过enforce选项让其中一个loader的执行顺序放到最前或是最后； 123456789101112131415161718192021222324252627module: &#123; rules: [ &#123; // 命中 JavaScript 文件 test: /\\.js$/, // 用 babel-loader 转换 JavaScript 文件 // ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度 use: ['babel-loader?cacheDirectory'], // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, 'src') &#125;, &#123; // 命中 SCSS 文件 test: /\\.scss$/, // 使用一组 Loader 去处理 SCSS 文件。 // 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。 use: ['style-loader', 'css-loader', 'sass-loader'], // 排除 node_modules 目录下的文件 exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; // 对非文本文件采用 file-loader 加载 test: /\\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/, use: ['file-loader'], &#125;, ]&#125; test，include和exclude除了支持字符串或者正则表达式类型，还支持数组类型。 pluginplugin用于扩展webpack的功能，各种各样的plugin几乎让webpack可以做任何构建相关的事情。 配置pluginplugin配置项接受一个数组，数组里的每一项都是一个要使用的plugin的实例，plugin需要的参数通过构造函数传入。 1234567891011const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');module.exports = &#123; plugins: [ // 所有页面都会用到的公共代码提取到 common 代码块中 new CommonsChunkPlugin(&#123; name: 'common', chunks: ['a', 'b'] &#125;), ]&#125;; devServer要配置DevServer，除了在配置文件中通过devServer传入参数外，还可以通过命令行参数传入。注意只有在通过DevServer去启动webpack配置文件里devServer才会生效，因为这写参数对应的功能都是DevServer提供的。 hotdevServer.hot 配置是否启用模块热替换功能。 headersdevServer.headers 配置项可以在 HTTP 响应中注入一些 HTTP 响应头，使用如下： 12345devServer:&#123; headers: &#123; &apos;X-foo&apos;:&apos;bar&apos; &#125;&#125; hostdevServer.host 配置项用于配置 DevServer 服务监听的地址。 例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 --host 0.0.0.0。 host 的默认值是 127.0.0.1 即只有本地可以访问 DevServer 的 HTTP 服务。 httpsDevServer 默认使用 HTTP 协议服务，它也能通过 HTTPS 协议服务。 有些情况下你必须使用 HTTPS，例如 HTTP2 和 Service Worker 就必须运行在 HTTPS 之上。 要切换成 HTTPS 服务，最简单的方式是： 123devServer:&#123; https: true&#125; DevServer 会自动的为你生成一份 HTTPS 证书。 实战使用ES6语言由于目前浏览器和node.js 对于ES6的标准不全面，这导致在开发中不敢全面地使用ES6。 通常我们需要把采用ES6编写的代码转换成目前已经支持良好的ES5代码，这其中包含了两部分： 把新的ES6语法用ES5来实现，例如ES6中的class语法使用ES5中的prototype来实现； 为新的API注入polyfill； Babel 可以很方便地做到以上几点。Babel是一个javascript编译器，能够将ES6代码转换为ES5代码，并且可以通过插件机制根据需求灵活扩展。在Babel执行编译的过程中，会从项目根目录下的.babelrc文件读取配置： 1234567891011121314151617181920&#123; \"plugins\": [ [ \"transform-runtime\", &#123; \"polyfill\": false &#125; ] ], \"presets\": [ [ \"es2015\", &#123; \"modules\": false &#125; ], \"stage-2\", \"react\" ]&#125; plugins其中plugins属性告诉Babel要使用哪些插件，插件可以控制如何转换代码。 例如上例中的transform-runtime 插件，此插件是Babel官方提供的一个插件，全名叫做babel-plugin-transform-runtime 。作用是减少冗余代码（由于Babel在吧ES6代码转换成ES5代码时通常需要一些ES5写的辅助函数来完成新的语法实现，这会造成代码冗余）。 Presetspresets 属性告诉Babel要转换的源码使用了哪些新的语法特性。presets其实是一组plugins的集合，每个plugin完成一个新语法的转换任务。 接入webpack在了解了Babel之后，下一步需要知道如何在webpack中使用它。由于Babel所做的事情是转换代码，所以应该通过Loader去接入Babel ： 1234567891011 module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], &#125;, ] &#125;, // 输出 source-map 方便直接调试 ES6 源码 devtool: 'source-map'&#125;; 不过在重新构建之前，需要先安装引入的依赖： 12# Webpack 接入 Babel 必须依赖的模块npm i -D babel-core babel-loader SCSS想要在项目中使用SCSS，那么则需要把SCSS编译为CSS的编译器。其中有一个叫做node-sass 的编译器。 node-sass 核心模块是由 C++ 编写，再用 Node.js 封装了一层，以供给其它 Node.js 调用。 node-sass 还支持通过命令行调用，先安装它到全局： 1npm i -g node-sass 再执行编译命令： 12# 把 main.scss 源文件编译成 main.cssnode-sass main.scss main.css 你就能在源码同目录下看到编译后的 main.css 文件。 接入webpack由于需要把SCSS源代码转换为CSS代码，那么最合适的方式就是使用loader ，webpack官方提供了对应的sass-loader 。 123456789101112module.exports = &#123; module: &#123; rules: [ &#123; // 增加对 SCSS 文件的支持 test: /\\.scss/, // SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader use: ['style-loader', 'css-loader', 'sass-loader'], &#125;, ] &#125;,&#125;; 以上配置通过正则 /\\.scss/ 匹配所有以 .scss 为后缀的 SCSS 文件，再分别使用3个 loader 去处理。具体处理流程如下： 首先通过sass-loader把SCSS源码转换为CSS代码，再把CSS代码交给css-loader处理。 css-loader会找出CSS代码中的@import和url()这样的导入语句，告诉webpack依赖这些资源。同时还支持css module、压缩css等功能，处理完之后再把结果交给style-loader处理。 style-loader会把css代码转换成为字符串，注入到javascript代码中，然后通过javascript去给DOM增加样式。 由于接入 sass-loader，项目需要安装这些新的依赖： 1npm i -D sass-loader css-loader style-loader 使用vue框架vue和react 一样，它们都推崇组件化和数据驱动视图的思想，视图和数据绑定在一起，数据改变视图会跟着改变，而无需直接操作视图。 以下为vue中的一个单文件组件： 12345678910111213141516171819202122&lt;!--渲染模版--&gt;&lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;!--样式描述--&gt;&lt;style scoped&gt; h1 &#123; color: red; &#125;&lt;/style&gt;&lt;!--组件逻辑--&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: 'Hello,Webpack' &#125; &#125; &#125;&lt;/script&gt; Vue 的单文件组件通过一个类似 HTML 文件的 .vue 文件就能描述清楚一个组件所需的模版、样式、逻辑。 main.js 入口文件： 1234567import Vue from 'vue'import App from './App.vue'new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 接入webpack目前最成熟和流行的开发vue项目的方式就是采用ES6加Babel转换。而Vue官方提供了对应的vue-loader可以非常方便地完成单文件组件的转换。 修改 Webpack 相关配置如下： 12345678module: &#123; rules: [ &#123; test: /\\.vue$/, use: ['vue-loader'], &#125;, ]&#125; 安装新引入的依赖： 1234# Vue 框架运行需要的库npm i -S vue# 构建所需的依赖npm i -D vue-loader css-loader vue-template-compiler 它们的作用分别如下： vue-loader ：解析和转换.vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 loader 去处理。 css-loader：加载由 vue-loader提取出的 CSS 代码。 vue-template-compiler：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码。 小结本文参考深入浅出webpack电子书 ，属于一些比较基础的内容，更多的配置内容，留待之后实际遇到后再来补充。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"GIT使用手册","slug":"git","date":"2018-05-21T12:33:30.000Z","updated":"2018-05-31T13:04:11.725Z","comments":true,"path":"2018/05/21/git/","link":"","permalink":"http://yoursite.com/2018/05/21/git/","excerpt":"","text":"GIT使用手册CommitGit仓库中的提交记录保存的是你的目录下所有文件的快照。每次进行提交时，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 以此命令进行提交： 1git commit Branch分支相当于：基于此提交以及它的所有父提交进行新的工作。 1git branch fixBug 可以用以下命令来切换分支： 1git checkout fixBug 你也可以用一下命令来创建一条分支，同时切换到新建的分支上： 1git checkout -b fixBug Merge我们通常新建一个分支，在其上开发某个功能，开发完成后再合并回主线。可以使用git merge 命令： 1git merge bugFix Rebase利用git rebase 命令可以将某个分支的提交记录取出，然后放到另外一个分支上，这样的好处就是可以创造更加线性的提示提交： 1git rebase matser 如上代码的作用就是：把分支上的提交记录取出线性添加知道master主线上。 HEADHEAD是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。HEAD总是指向你当前分支上的最近一次提交。 分离HEAD由于HEAD的通常指向某个分支，然后某个分支指向某个提交记录，而分离HEAD就要做到使得HEAD直接指向某个提交记录： 1git checkout C4 其中C4是该提交记录的哈希值。 由于真正地哈希值通常很长并且很难记忆，所以Git 提供了相对引用，可以以某个容易以及的节点为基础，向前移动若干个提交： 1git checkout bugFix^^ 以上代码的作用是：分离HEAD，使HEAD指向当前bugFix分支最新提交之前的前两个父提交。可以用以下代码代替： 1git checkout bugFix~2 强制移动分支若是我们要强制移动某个分支到指定位置，可以使用如下方法： 1git branch -f master HEAD~2 撤销变更一共有两种用于撤销变更的方法：其中一种是git reset，该方法用于撤销本地的提交(撤销完成之后，之前提交造成的改动还在，只是没有被加入到暂存区中)： 1git reset HEAD~2 还有另外一种命令：git revert 该命令用于撤销已经提交到远程仓库上的提交(通过重新添加一个提交来达到撤销的效果)： 1git revert HEAD 整理提交记录cherry-pick当我们想要把某分支上的某些提交记录添加到当前分支上，可以使用cherry-pick 命令(原分支上的这些记录并不会消失)： 1git cherry-pick C2 C4 其中，C2与C4全都是提交的哈希值。与git rebase不同，cherry-pick 不会改变各个分支原来的指向。 Tags通过以上的学习我们发现：分支很容易被人为移动，并且有新的提交时，它也会移动。那么有没有什么可以永远指向某个提交记录的标识呢？ 可以使用git tag ： 1git tag v1 C2 其中，v1 为标签的名字，而C2 为标签位置提交的哈希值。 Clone可以使用git clone命令从远程仓库克隆一份副本放到本地仓库。当我们从远程仓库复制了一份副本之后，你会发现本地的副本将会有两个分支：master和o/master 。其中后者表示的就是远程的分支，不能在此分支上直接改动，因为此分支的作用就是给开发者表示clone下来时，对比远程分支和本地分支的不同。 Fetch我们可以通过git fetch 来同步远程分支的状态。fetch 一共会做两件事情：①将本地仓库与远程仓库做对比，把本地仓库所没有的一些提交添加到本地仓库的提交记录中；②将本地仓库中的o/master等各个远程分支指向远程仓库中它们应该指向的位置。 注意：我们并没有将远程仓库的状态同步到本地仓库，即本地仓库中的文件还没有发生改变。 1git fetch Pull与fetch不同，我们可以使用git pull命令来使得本地仓库取得远程仓库的所有状态。git pull相当于接连使用了git fetch和git merge o/master。 1git pull 若给此命令带上一些参数，将会得到不一样的结果： 1git pull --rebase 以上命令相当于接连使用了git fetch和git rebase 。 Push我们可以通过git push命令来向远程仓库提交我们的变更，若是成功push，那么远程仓库将会得到更新，同时本地仓库的o/master分支也会更新到最新状态： 1git push 小结本篇文章参考了LearnGitBranching ，其中有很多比较不常见的命令和内容没有写进文章中，留待之后有需求时再细细查看。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Mongoose入门指南","slug":"mongoose","date":"2018-05-21T12:33:30.000Z","updated":"2018-05-31T13:08:10.467Z","comments":true,"path":"2018/05/21/mongoose/","link":"","permalink":"http://yoursite.com/2018/05/21/mongoose/","excerpt":"","text":"Mongoose入门指南安装当你已经安装了MongoDB和Node.js之后，你就可以安装mongoose ： 1$ npm install mongoose 连接第一步我们需要做的，就是在项目中引入mongoose，并且代替使用MongoDB来连接到需要操作的数据库： 12var mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); 当以上代码生效时，我们将会有一个持续链接本地数据库的连接，我们可以对其进行监听： 12345var db = mongoose.connection;db.on('error', console.error.bind(console, 'connection error:'));db.once('open', function() &#123; // we're connected!&#125;); Schema在mongoose中，所有的一切都是由Schema驱动的，例如： 123var kittySchema = mongoose.Schema(&#123; name: String&#125;); 接下来我们需要根据创建的Schema (模式)，来生成一个集合model(相当于关系型数据库中的表)。 1var Kitten = mongoose.model('Kitten', kittySchema); 而model 就相当于一个类，我们通过这个类来创建相应集合中的文档： 12var silence = new Kitten(&#123; name: 'Silence' &#125;);console.log(silence.name); // 'Silence' 同样的，我们可以为这个类添加方法(不过需要注意：为Schema 添加方法需要在声明model之前)： 123456789// NOTE: methods must be added to the schema before compiling it with mongoose.model()kittySchema.methods.speak = function () &#123; var greeting = this.name ? \"Meow name is \" + this.name : \"I don't have a name\"; console.log(greeting);&#125;var Kitten = mongoose.model('Kitten', kittySchema); 将可以通过以下方式调用方法： 12var fluffy = new Kitten(&#123; name: 'fluffy' &#125;);fluffy.speak(); // \"Meow name is fluffy\" 我们可以通过对实例 调用save 方法将它们存储到数据库中： 1234fluffy.save(function (err, fluffy) &#123; if (err) return console.error(err); fluffy.speak(); &#125;); 同样的，可以对model 使用find 方法来从数据库中查询文档： 1234Kitten.find(function (err, kittens) &#123; if (err) return console.error(err); console.log(kittens);&#125;) 我们也可以获取过滤信息来取得想要的内容： 1Kitten.find(&#123; name: /^fluff/ &#125;, callback); 小结本文参考Mongoose官方文档 ，具体的API可以在需要时进行查看。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"Express入门指南","slug":"Express","date":"2018-05-18T12:33:30.000Z","updated":"2018-05-31T13:22:50.961Z","comments":true,"path":"2018/05/18/Express/","link":"","permalink":"http://yoursite.com/2018/05/18/Express/","excerpt":"","text":"Express入门指南路由路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback...], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例： 1234567var express = require('express');var app = express();// respond with \"hello world\" when a GET request is made to the homepageapp.get('/', function(req, res) &#123; res.send('hello world');&#125;); 路由方法app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自 /secret的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。 1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 注意：查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： 1234567891011121314// 匹配根路径的请求app.get('/', function (req, res) &#123; res.send('root');&#125;);// 匹配 /about 路径的请求app.get('/about', function (req, res) &#123; res.send('about');&#125;);// 匹配 /random.text 路径的请求app.get('/random.text', function (req, res) &#123; res.send('random.text');&#125;); 路由句柄可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用 next(&#39;route&#39;) 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 使用多个回调函数处理路由（记得指定 next 对象）： 123456app.get('/example/b', function (req, res, next) &#123; console.log('response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 响应方法下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件。 res.end() 终结响应处理流程。 res.json() 发送一个 JSON 格式的响应。 res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。 res.redirect() 重定向请求。 res.render() 渲染视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位字节流的形式发送文件。 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 app.route()可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。 12345678910app.route('/book') .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 123456789101112131415161718var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块： 123var birds = require('./birds');...app.use('/birds', birds); 中间件Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件（Middleware） 是一个函数，它可以访问请求对象（request object(req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。 中间件的功能包括： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。 应用级中间件应用级中间件绑定到 app 对象使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如： 123456789101112131415161718var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 如果需要在中间件栈中跳过剩余中间件，调用 next(&#39;route&#39;) 方法将控制权交给下一个路由。 注意： next(&#39;route&#39;) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。 123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 1var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载。 12345678910111213141516171819202122232425262728293031323334353637var app = express();var router = express.Router();// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 负责将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面router.get('/user/:id', function (req, res, next) &#123; console.log(req.params.id); res.render('special');&#125;);// 将路由挂载至应用app.use('/', router); 错误处理中间件注意：错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 内置中间件express.static(root, [options])express.static 是 Express 唯一内置的中间件。它基于serve-static，负责在 Express 应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 12345678910111213var options = &#123; dotfiles: 'ignore', etag: false, extensions: ['htm', 'html'], index: false, maxAge: '1d', redirect: false, setHeaders: function (res, path, stat) &#123; res.set('x-timestamp', Date.now()); &#125;&#125;app.use(express.static('public', options)); 错误处理在其他 app.use() 和路由调用后，最后定义错误处理中间件，比如： 12345678var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑&#125;); 如果向 next() 传入参数（除了 ‘route’ 字符串），Express 会认为当前请求有错误的输出，因此跳过后续其他非错误处理和路由/中间件函数。如果需做特殊处理，需要创建新的错误处理路由。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}]},{"title":"ESLint与EditorConfig","slug":"ESLint-EditorConfig","date":"2018-05-15T12:33:30.000Z","updated":"2018-05-31T13:21:57.416Z","comments":true,"path":"2018/05/15/ESLint-EditorConfig/","link":"","permalink":"http://yoursite.com/2018/05/15/ESLint-EditorConfig/","excerpt":"","text":"ESLint与EditorConfigESLintESLint是什么？ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。 它是完全插件化的。提供以下校验： 语法错误校验 不重要或丢失的标点符号，如分号 没法运行到的代码块 未被使用的参数提醒 漏掉的结束符，如} 确保样式的统一规则，如sass或者less 检查变量的命名 全局安装我们可以使用npm全局安装ESLint ： 1$ npm install -g eslint 接着可以设置一个配置文件： 1$ eslint --init 此时会出现三个选项： Answer questions about your style ：初始化程序通过一个个问题的方式来帮助你完成代码风格的初始化； Use a popular style guide ：使用目前流行的代码风格配置文件； Inspect your JavaScript file(s) ：检查你的JS文件； 我们可以选择第二个选项，选择一个代码规范（由于ESLint是可扩展的，所以我们还可以扩展自己的自定义规则）： 选择后即可完成初始化。 之后，你可以在任何文件或目录运行 ESLint： 1$ eslint yourfile.js 注意：若是选择全局安装，则所以依赖的插件都要全局安装。如果觉得这样比较麻烦，俺么可以选择本地安装。 配置ESlint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。 可以使用 JavaScript、JSON 或者 YAML 文件为整个目录（处理你的主目录）和它的子目录指定配置信息。可以配置一个独立的 .eslintrc.* 文件，或者直接在 package.json 文件里的 eslintConfig字段指定配置，ESLint 会查找和自动读取它们 。 有很多信息可以配置： Environments - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。 Globals - 脚本在执行期间访问的额外的全局变量。 Rules - 启用的规则及其各自的错误级别。 我们可以通过parserOptions 属性设置解析器选项： ecmaVersion ：默认设置为3，5（默认）， 你可以使用 6、7、8 或 9 来指定你想要使用的 ECMAScript 版本； sourceType - 设置为 &quot;script&quot; (默认) 或 &quot;module&quot;（如果你的代码是 ECMAScript 模块)； ecmaFeatures - 这是个对象，表示你想使用的额外的语言特性: globalReturn - 允许在全局作用域下使用 return 语句； impliedStrict - 启用全局严格模式； jsx - 启用 JSX ； .eslintrc.json 文件示例： 123456789101112&#123; \"parserOptions\": &#123; \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": &#123; \"jsx\": true &#125; &#125;, \"rules\": &#123; \"semi\": 2 &#125;&#125; 可以使用具体的规则列表 ，来添加自己想要的规则。其中有个扳手标志的规则代表可以自动修复 ： 12$ eslint yourfile.js --fix//此命令将会修复那些可以自动修复的功能 在IDE中开启ESLint检查此处只示范在Webstorm中开启ESLint检查的步骤： 勾选Enable选项即可。 若需要自动修复，只需要在发生报错的代码位置右键fix即可。 EditorConfigEditorConfig 是一个保持缩进风格的一致的工具，当多人共同开发一个项目的时候，往往会出现每个人用不同编辑器的情况，而且有的人用 tab 缩进，有的人用 2 个空格缩进，有的人用 4 个空格缩进，EditorConfig 就是为了解决这个问题而诞生。 示例文件： 1234567891011121314151617181920# editorconfig.org#root表示此为最顶层的config文件，不需要再进行查找root = true[*]#tab是hard tabs而space为soft tabsindent_style = tabindent_size = 2end_of_line = lfcharset = utf-8trim_trailing_whitespace = trueinsert_final_newline = truetab_width = 2[*.md]#关闭自动去除行尾空格trim_trailing_whitespace = false[Makefile]indent_style = tab 具体属性可以查看EditorConfig Properties。 小结此篇文章关于ESLint的介绍非常基础，需要之后自己配置一个完整的规则才能更加深入了解。 本文参考： EsLint入门学习整理； ESLint官方文档； EditorConfig Properties；","categories":[],"tags":[{"name":"ESLint","slug":"ESLint","permalink":"http://yoursite.com/tags/ESLint/"}]},{"title":"config-lite","slug":"config-lite","date":"2018-05-15T12:33:30.000Z","updated":"2018-05-31T13:35:29.251Z","comments":true,"path":"2018/05/15/config-lite/","link":"","permalink":"http://yoursite.com/2018/05/15/config-lite/","excerpt":"","text":"config-lite不管是小项目还是大项目，将配置与代码分离是一个非常好的做法。我们通常将配置写到一个配置文件里，如 config.js 或 config.json ，并放到项目的根目录下。 config-lite 是一个轻量的读取配置文件的模块。config-lite 会根据环境变量（NODE_ENV）的不同加载 config 目录下不同的配置文件。如果不设置 NODE_ENV，则读取默认的 default 配置文件，如果设置了 NODE_ENV，则会合并指定的配置文件和 default 配置文件作为配置，config-lite 支持 .js、.json、.node、.yml、.yaml 后缀的文件。 如果程序以 NODE_ENV=test node app 启动，则 config-lite 会依次降级查找 config/test.js、config/test.json、config/test.node、config/test.yml、config/test.yaml 并合并 default 配置; 如果程序以 NODE_ENV=production node app启动，则 config-lite 会依次降级查找 config/production.js、config/production.json、config/production.node、config/production.yml、config/production.yaml 并合并 default 配置。 config-lite 还支持冒泡查找配置，即从传入的路径开始，从该目录不断往上一级目录查找 config 目录，直到找到或者到达根目录为止。 config/default.js： 123456789module.exports = &#123; port: 3000, session: &#123; secret: 'myblog', key: 'myblog', maxAge: 2592000000 &#125;, mongodb: 'mongodb://localhost:27017/myblog'&#125; 原文地址：配置文件；","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"MongoDB基础","slug":"MongoDB","date":"2018-05-12T12:33:30.000Z","updated":"2018-05-31T13:23:33.282Z","comments":true,"path":"2018/05/12/MongoDB/","link":"","permalink":"http://yoursite.com/2018/05/12/MongoDB/","excerpt":"","text":"MongoDB基础简介丰富的数据模型MongoDB是面向文档的数据库，不是关系型数据库。放弃关系模型的主要原因就是为了获得更加方便的扩展性。面向文档的方式可以将文档或者数组内嵌进来，所以用一条记录就可以表示非常复杂的层次关系。 容易扩展丰富的功能 索引：MongoDB支持通用辅助索引，能进行多种快速查询； 存储JavaScript ：开发人员不必使用存储过程了，可以直接在服务端存取JavaScript 的函数和值； 聚合 固定集合：集合的大小是有上限的； 文件存储：MongoDB支持用一种容易使用的协议存储大型文件和文件的元数据； 不牺牲速度便捷的管理MongoDB尽量让服务器自治来简化数据库的管理。 入门文档文档是MongoDB的核心概念。多个键及其关联的值有序地放置在一起便是文档。 在JavaScript里面，文档表示为对象： 1&#123;\"greeting\" : \"Hello, world!\"&#125; 文档的几个概念： 文档中的键/值对是有序的； 文档中的值不仅可以是在双引号里边的字符串，还可以是其他几种数据类型； MongoDB 文档不但区分类型，还区分大小写，同时不能有重复的键： 1234567&#123;\"foo\" : 3&#125;&#123;\"foo\" : \"3\"&#125;//以上两个文档是不同的&#123;\"foo\" : 3&#125;&#123;\"Foo\" : 3&#125;//以上两个文档也是不同的&#123;\"greeting\" : \"Hello, world!\", \"greeting\": \"Hello, MongoDB!\"&#125; 集合集合就是一组文档 。如果说MongoDB 中的文档是类似于关系型数据库中的行，那么集合就如同表。 无模式集合是无模式的。这意味着一个集合里面的文档可以是各式各样的。例如： 123&#123;\"greeting\" : \"Hello, world!\"&#125;&#123;\"foo\" : 5&#125;//两个文档不仅是值得类型不相同，他们的键也是完全不一样的 命名我们可以通过名字来标识集合 子集合组织集合的一种惯例是使用. 字符分开的按命名空间划分的子集合。例如，一个带有博客功能的应用可能包括两个集合，分别是blog.posts和blog.authors 。这样做的目的只是为了使组织结构更好些，也就是说blog 这个集合(这里根本不需要存在)及其子集合没有任何关系。 数据库MongoDB 中多个文档组成集合，同样多个集合可以组成数据库。一个MongoDB 实例可以承载多个数据库，它们之间可视为完全独立的。 注意：数据库名最终会变成文件系统里的文件，所以在命名规范上将会有一些额外的限制。 MongoDB shellMongoDB 自带一个JavaScript shell ，可以从命令行与MongoDB 实例交互。 MongoDB客户端shell 真正的威力在于它是一个独立的MongoDB 客户端。开启时，shell 会连接到MongoDB 服务器的test数据库，并将这个数据库连接赋值给全局变量db 。这个变量是通过shell访问MongoDB 的主要入口点。 shell中的基本操作在shell查看操作数据会用到4个基本操作：创建、读取、更新和删除。 创建insert函数将会添加一个文档到集合中。例如，加入要存储一篇博客文章。首先，创建一个局部变量post ： 12345post = &#123; \"title\": \"My Blog Post\", \"content\": \"Here's my blog post\", \"date\": new Date()&#125; 这个对象是个有效的MongoDB 文档，所以可以用insert方法将其保存到blog集合中： 123db.blog.insert(post);//验证是否已经完成存储，可以用以下函数查看db.blog.find(); 读取find会返回集合里面的所有文档。若只是想查看一个文档，我们可以用findOne。 更新如果要更改博客文章，就要用到update了。update 接受（至少）两个参数：第一个参数是要更新文档的限定条件，第二个是新的文档。假设决定给我们先前写的文章增加评论内容，则需要添加一个新的键： 12post.comments = [];db.blog.update(&#123;title: \"My Blog Post\"&#125;, post); 删除remove用于将文档从数据库中永久性地删除： 1db.blog.remove(&#123;title: \"My Blog Post\"&#125;); 数据类型MongoDB支持将多种数据类型作为文档中的值。 基本数据类型MongoDB 类似于JSON ，在概念上和JavaScript中的对象神似。JSON包含六种数据类型：null，布尔，数字，字符创，数组和对象。但是却没有日期类型、正则表达式或者函数类型。 MongoDB在保留JSON 的基本键/值对特性的基础上，添加了一些其他的数据类型: 1234567891011121314151617&#123;\"x\": ObjectId()&#125;//对象ID类型&#123;\"x\": new Date()&#125;//日期类型&#123;\"x\": /foobar/i&#125;//正则表达式类型&#123;\"x\": function() &#123; /*...*/ &#125;&#125;//还可以包含JavaScript代码&#123;\"x\": undefined&#125;//未定义类型&#123;\"x\": &#123;\"foo\": \"bar\"&#125;&#125;//内嵌文档 创建、更新及删除文档插入并保存文档利用insert方法来插入新的文档，这个操作会给文档增加一个_id键： 1db.foo.insert(&#123;\"bar\": \"baz\"&#125;); 删除文档可以利用remove方法来清除集合中的所有文档或某些文档： 1db.user.remove(); 删除文档通常会很快，但是要清除整个集合，直接删除集合（然后重建索引）会更快： 1db.drop_collection(\"bar\"); 更新文档文档替换更新最简单的 情况就是完全用一个新文档替代匹配的文档。这适用于模式结构发生了较大变化的时候。例如，想要将以下用户文档： 123456&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"name\": \"joe\", \"friends\": 32, \"enemies\": 2&#125; 改变为以下文档： 123456789&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"username\": \"joe\", \"relationships\": &#123; \"friends\": 32, \"enemies\": 2 &#125;&#125; 可以使用update来替换文档： 1234567let joe = db.users.findOne(&#123;\"name\": \"joe\"&#125;);joe.relationships = &#123;\"friends\": joe.friends, \"enemies\": joe.enemies&#125;;joe.username = joe.name;delete joe.friends;delete joe.enemies;delete joe.name;db.users.update(&#123;\"name\": \"joe&#125;, joe); 注意：常见错误就是查询条件匹配了多个文档，更新时由于第二个参数的存在就会产生重复_id 值，数据库就会报错，然后不作出任何修改。 使用修改器通常文档只有一部分需要更新。利用原子的更新修改器，可以使得这部分更新极为高效。 假设要修改某个文档中的pageviews属性的值，使其加一： 1db.analytics.update(&#123;\"url\": \"www.example.com\"&#125;, &#123;\"$inc\": &#123;\"pageviews\": 1&#125;&#125;); $set修改器$set 用来指定一个键的值。如果这个键不存在，则创建它： 1db.users.update(&#123;\"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\")&#125;, &#123;\"$set\": &#123;\"favorite book\": \"war and peace\"&#125;&#125;) 若要进行删除，可以使用$unset修改器： 1db.users.update(&#123;\"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\")&#125;, &#123;\"$unset\": &#123;\"favorite book\": 1&#125;&#125;) 增加和减少$inc修改器用来增加已有键的值，或者在键不存在时创建一个键： 1db.games.update(&#123;\"game\": \"pinball\", \"user\": \"joe\"&#125;, &#123;\"$inc\": &#123;\"score\": 50&#125;&#125;); 数组修改器有一类很好的修改器可用于操作数组。如果指定的键已经存在，那么$push 会向已有的数组末尾加入一个元素，要是没有的话就会创建一个新的数组。例如： 123456db.blog.posts.findOne()&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"title\": \"A blog post\", \"content\": \"...\"&#125; 若要添加一个包含一个数组的comments键 ： 12345db.blog.posts.update(&#123;\"title\": \"A blog post\"&#125;, &#123;$push: &#123;\"comments\": &#123; \"name\": \"joe\", \"email\": \"joe@example.com\", \"content\": \"nice post.\"&#125;&#125;&#125;) 执行完之后，该文档变为： 12345678910111213db.blog.posts.findOne()&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"title\": \"A blog post\", \"content\": \"...\", \"comments\": [ &#123; \"name\": \"joe\", \"email\": \"joe@example.com\", \"content\": \"nice post.\" &#125; ]&#125; 经常有这种情况，如果一个值不在数组里面就把它加进去。可以在查询文档中用$ne 来实现： 1db.papers.update(&#123;\"authors cited\": &#123;\"$ne\" : \"Richaie\"&#125;&#125;, &#123;$push: &#123;\"authors cited\": \"Richa\"&#125;&#125;) 同时也可以用$addToSet来代替$ne : 1db.users.update(&#123;\"title\": \"A blog post\"&#125;, &#123;\"$addToSet\": &#123;\"emails\": \"joe@gmail.com\"&#125;&#125;) 但是$addToSet可以完成$ne 做不到的操作，比如 可以将$addToSet 和$each 组合起来： 1db.users.update(&#123;\"title\": \"A blog post\"&#125;, &#123;\"$addToSet\": &#123;\"emails\": &#123;\"$each\": [\"joe@gmail.com\", \"joe@php.net\", \"joe@python.org\"]&#125;&#125;&#125;); 有几个从数组中删除元素的方法。若是把数组看成队列或者是栈，可以用$pop 这个修改器从数组的任意一端删除元素： 1234&#123;$pop: &#123;key: 1&#125;&#125;//以上为从数组末尾删除元素&#123;$pop: &#123;ket: -1&#125;&#125;//以上为从头部删除 有时需要依据特定条件来删除元素，而不仅仅是依据位置，$pull可以做到： 123456789db.list.find()&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"todo\": [ \"dishes\", \"laundry\", \"dry cleaning\" ]&#125; 若想删除todo 中的某个元素： 123456789db.lists.update(&#123;&#125;, &#123;\"$pull\": &#123;\"todo\": \"laundry\"&#125;&#125;);db.list.find()&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"todo\": [ \"dishes\", \"dry cleaning\" ]&#125; 数组的定位修改器若是数组有多个值，而我们只想对其中的一部分进行操作，有两种方法操作数组中的值：通过位置或者定位操作符$ 。 upsertupsert是一种特殊的更新。要是没有文档符合更新条件，就会以这个条件和更新文档作为基础创建一个新文档。若是找到了，则正常更新： 12db.analytics.update(&#123;\"url\": \"/blog\"&#125;, &#123;\"$inc\": &#123;\"visits\": 1&#125;&#125;, true);//第三个参数表示是否为upsert操作 更新多个文档默认情况下，更新只能对符合匹配条件的第一个文档执行操作。要是有多个文档符合条件，其余的文档就没有变化。要使得所有的匹配文档都得到更新，可以设置uodate的第四个参数为true。 查询find简介指定返回的键有时候不需要将所有的键/值对都返回。遇到这种情况，可以通过find的第二个参数来指定想要的键： 1234567db.users.find(&#123;&#125;, &#123;\"username\": 1, \"email\": 1&#125;);&#123; \"_id\": ObjectId(\"4b2b9f67alf631733d917a7a\"), \"username\": \"joe\", \"email\": \"joe@example.com\"&#125;//_id键总是会被返回 也可以用第二个参数剔除查询结果中的某个键/值对： 1234db.users.find(&#123;&#125;, &#123;\"username\": 1, \"_id\": 0&#125;);&#123; \"username\": \"joe\"&#125; 查询条件查询条件$lt、$lte 、$gt 和$gte 就是全部的比较操作符，分别对应&lt; 、&lt;= 、&gt; 和&gt;= 。可以将其组合起来以便查找一个范围的值： 1db.users.find(&#123;\"age\": &#123;\"$gte\": 18, \"$lte\": 30&#125;&#125;); 对于文档的键值不等于某个特定值的情况，就要使用另一种条件操作符$ne了 ，它表示不相等： 1db.users.find(&#123;\"username\": &#123;\"$ne\": \"joe\"&#125;&#125;); OR查询MongoDB 中有两种方式进行OR查询。 $in非常灵活，可以指定不同的类型的条件和值： 12db.reffle.find(&#123;\"ticket_no\": &#123;\"$in\": [12345, \"joe\"]&#125;&#125;);//匹配\"user_id\"等于12345或者\"joe\"的文档 与$in 相对的是$nin ，将返回与数组中所有条件都不匹配的文档。 $in能对单个键做OR查询，但是要对多个键做OR查询的时候，应该使用$or ： 1db.reffle.find(&#123;\"$or\": [&#123;\"ticket_no\": 725&#125;, &#123;\"winner\": true&#125;]); 而$or还可以含有其他条件语句（例如$in）： 1db.reffle.find(&#123;\"$or\": [&#123;\"ticket_no\": &#123;\"$in\": [725, 542, 390]&#125;, &#123;\"winner\": true&#125;]); 条件语句的规则根据以上所述，可以肯定：条件句是内层文档的键，而修改器是外层文档的键。 一个键可以应用多个条件，但是一个键不能对应多个更新修改器。 特定于类型的查询null需要注意：null值不仅仅匹配自身，而且匹配“不存在的”。所以，这种匹配还会返回缺少这个键的所有文档： 12db.c.find(&#123;\"z\": null&#125;);//还会匹配所有不含z键值的文档 如果仅仅想要匹配键值为null的文档，既要检查该键的值是否为null，还要通过$exists条件判定键值是否已存在： 1db.c.find(&#123;\"z\": &#123;\"$in\": [null], \"$exists\": true&#125;&#125;); 不幸的是，没有$eq操作符，所以看上去就有费解，但是只有一个元素的$in 操作符效果是一样的。 查询数组如果对于以下的文档： 1&#123;\"fruit\": [\"apple\", \"banana\", \"peach\"]&#125; 用以下的查询语句将会匹配到该文档： 1db.food.find(&#123;\"fruit\": \"banana\"&#125;) $all如果要通过多个元素来匹配数组，就要使用$all来查询了： 1db.food.find(\"fruit\": &#123;\"$all\": [\"apple\", \"banana\", \"peach\"]&#125;); 以上查询语句将会匹配所有拥有fruit键，并且键值包括这三者的文档。（不需要顺序一致） 绝对匹配的查询可以用一下语句： 12db.food.find(&#123;\"fruit\": [\"apple\", \"banana\", \"peach\"]&#125;&#125;);//不过它匹配到的文档要求这三个数组元素必须按顺序排列 要是想查询数组指定位置的元素，则需要使用key.index语法指定下标，例如： 1db.food.find(&#123;\"fruit.2\": \"peach\"); $size$size可以查询指定长度的数组： 1db.food.find(&#123;\"fruit\": &#123;\"$size\": 3&#125;&#125;); $where查询键/值对是很有力的查询方式，但是依然有些需求它无法表达。而利用$where子句，可以执行任意JavaScript作为查询的一部分。这就使得查询能做几乎任何事情。例如： 1234db.foo.find(&#123;\"$where\": \"function() &#123; return this.x + this.y == 10&#125;\"&#125;)//如果函数返回true，文档就做为结果的一部分被返回；如果为false，则不然 注意：$where查询在速度上要比常规查询慢很多。 游标数据库使用游标来返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。 limit、skip和sort最常见的查询选项就是限制返回结果的数量，忽略一定数量的结果并排序。所有这些选项一定要在查询被派发到服务器之前添加： 1let cursor = db.stock.find(&#123;\"desc\": \"mp3\"&#125;).limit(50).skip(50).sort(&#123;\"price\": -1&#125;); 以上查询意为：查询50条desc 键值为mp3 的文档，并且跳过前50个然后按price键值降序排列后返回。 不用skip对结果分页最简单的分页方法就是用limit放回结果的第一页，然后将每个后续页面作为相对于开始的偏移量返回。 1234let page1 = db.foo.find(criteria).limit(100);let page2 = db.foo.find(criteria).skip(100).limit(100);let page3 = db.foo.find(criteria).skip(200).limit(100);//不要使用这种方法，这会导致处理很慢 索引索引就是用来加速查询的。 索引简介创建索引需要使用ensureIndex方法： 12db.people.ensureIndex(&#123;\"username\": 1&#125;);//对于同一个集合，同样的索引只需要创建一次 可以传递给ensureIndex一组值为1或者-1的键，表示索引创建的方向，通常在创建多个索引时发挥作用： 1db.ensureIndex(&#123;\"date\": 1, \"username\": -1&#125;); 创建索引的缺点就是每次插入、更新和删除时都会产生额外的开销。这是因为数据库不但需要执行这些操作，还要将这些操作在集合的索引中标记。因此，要尽可能地少创建索引。 索引名称集合中的每个索引都有一个字符串类型的名字，来唯一标识索引，可以在创建索引时指定它的名字： 1db.foo.ensureIndex(&#123;\"a\": 1, \"b\": -1&#125;, &#123;\"name\": \"alphabet\"&#125;); 唯一索引唯一索引可以确保集合的每一个文档的指定键都有唯一值。例如，如果想保证文档的username键都有不一样的值，创建一个唯一索引就好了： 1db.people.ensureIndex(&#123;\"username\": 1&#125;, &#123;\"unique\": true&#125;); 注意：默认情况下，insert并不检查文档是否插入过了。所以，为了避免插入的文档中包含与唯一键重复的值，可能要用安全插入才能满足要求。 聚合MongoDB除了基本的查询功能，还提供了很多强大的聚合工具。 countcount是最简单的聚合工具，返回集合中的文档数量： 12db.foo.count();0 也可以传递查询，MongoDB 则会计算查询结果的数量： 12db.foo.insert(&#123;\"x\": 2&#125;);2 distinctdistinct 用来找出给定键的所有不同的值。使用时必须指定集合和键，假设有以下文档： 1234&#123;\"name\": \"Ada\", \"age\": 20&#125;&#123;\"name\": \"Fred\", \"age\": 35&#125;&#123;\"name\": \"Susan\", \"age\": 60&#125;&#123;\"name\": \"Andy\", \"age\": 35&#125; 对age键使用distinct会获得所有不同的年龄： 123db.runCommand(&#123;\"distinct\": \"people\", \"key\": \"age\"&#125;);//将会返回如下数据：&#123;\"value\": [20, 35, 60], \"ok\": 1&#125;; groupgroup 可以先选定分组所依据的键，而后MongoDB会将集合依据选定值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。 例如，有一个集合存储了某只股票近30天的价格变动： 12345&#123;\"day\": \"2010/10/03\", \"time\": \"10/3/2010 03:57:01 GMT-400\", \"price\": 4.23&#125;&#123;\"day\": \"2010/10/04\", \"time\": \"10/4/2010 11:28:39 GMT-400\", \"price\": 4.27&#125;&#123;\"day\": \"2010/10/03\", \"time\": \"10/3/2010 05:00:23 GMT-400\", \"price\": 4.10&#125;&#123;\"day\": \"2010/10/06\", \"time\": \"10/6/2010 05:27:58 GMT-400\", \"price\": 4.30&#125;&#123;\"day\": \"2010/10/04\", \"time\": \"10/4/2010 08:34:50 GMT-400\", \"price\": 4.01&#125; 通过以下操作： 12345678910111213141516db.runCommand(&#123;\"group\": &#123; \"ns\": \"stocks\", //ns指定要进行分组的集合 \"key\": \"day\", //分组依据的键 \"initial\": &#123;\"time\": 0&#125;， //每一组reduce函数调用的初始变量 \"$reduce\": function(doc, prev)&#123; if(doc.time &gt; prev.time) &#123; prev.price = doc.price; prev.time = doc.time; &#125; &#125;, \"condition\": &#123;\"day\": &#123;\"$gt\": \"2010/09/30\"&#125;&#125; //可以限定查询条件为一个月内的价格变动&#125;&#125;) 最后将会返回由30个文档组成的数组，每个组一个文档。如果有的文档没有依据的键，就都会被分到同一组，相应部分就会使用day: null 这样的形式。 将函数作为键使用有些时候分组所依据的条件非常复杂，不仅是一个键，那么可以把函数作为键： 123456db.posts.group( \"ns\": \"posts\", \"$keyf\": function(x) &#123; return x.category.toLowerCase();&#125;, //注意是$keyf \"initializer\": ...) 总结之后在写。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"Call,aplly与bind","slug":"Call","date":"2018-04-08T12:33:30.000Z","updated":"2018-05-31T12:56:12.413Z","comments":true,"path":"2018/04/08/Call/","link":"","permalink":"http://yoursite.com/2018/04/08/Call/","excerpt":"","text":"详解call、apply和bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。 call该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。 不传，或者传null,undefined， 函数中的 this 指向 window 对象 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean 传递一个对象，函数中的 this 指向这个对象 123456789101112131415function a()&#123; console.log(this); //输出函数a中的this对象&#125;function b()&#123;&#125; //定义函数b var obj = &#123;name:'onepixel'&#125;; //定义对象obj a.call(); //windowa.call(null); //windowa.call(undefined);//windowa.call(1); //Numbera.call(''); //Stringa.call(true); //Booleana.call(b);// function b()&#123;&#125;a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性: 1234567891011121314151617181920var a = &#123; name:'onepixel', //定义a的属性 say:function()&#123; //定义a的方法 console.log(\"Hi,I'm function a!\"); &#125;&#125;; function b(name)&#123; console.log(\"Post params: \"+ name); console.log(\"I'm \"+ this.name); this.say();&#125; b.call(a,'test');&gt;&gt;Post params: testI'm onepixelI'm function a! 相当于调用了对象a上的函数b,而实际上a中并没有定义函数b。 applyapply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。 注意：虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递： 12345function b(x,y,z)&#123; console.log(x,y,z);&#125; b.apply(null,[1,2,3]); // 1 2 3 bind调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数: 12345678910111213141516var obj = &#123;name:'onepixel'&#125;; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */document.addEventListener('click',onClick.bind(obj,'p1','p2'),false); //当点击网页时触发并执行function onClick(a,b)&#123; console.log( this.name, //onepixel a, //p1 b //p2 )&#125; 实现继承 JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字, call和apply可以实现继承： 12345678910111213141516function Animal(name,weight)&#123; this.name = name; this.weight = weight;&#125; function Cat()&#123; Animal.call(this,'cat','50'); //Animal.apply(this,['cat','50']); this.say = function()&#123; console.log(\"I am \" + this.name+\",my weight is \" + this.weight); &#125;&#125; var cat = new Cat();cat.say();//I am cat,my weight is 50 移花接木JavaScript 中有一个非标准专业术语：ArrayLike (类数组/伪数组)。 ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。 12345678910111213141516function test()&#123; // 检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); // 判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item)&#123; console.log(item); // 1 2 3 4 &#125;); &#125;test(1,2,3,4); apply相比call的优势对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max： 123var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"深入理解new操作符","slug":"new","date":"2018-04-08T12:33:30.000Z","updated":"2018-05-31T13:09:12.185Z","comments":true,"path":"2018/04/08/new/","link":"","permalink":"http://yoursite.com/2018/04/08/new/","excerpt":"","text":"深入理解new操作符在 JavaScript 中，万物皆对象，为什么还要通过 new 来产生对象？ 1234567891011121314151617181920function Animal(name)&#123; this.name = name;&#125; Animal.color = \"black\"; Animal.prototype.say = function()&#123; console.log(\"I'm \" + this.name); &#125;; var cat = new Animal(\"cat\"); console.log( cat.name, //cat cat.height //undefined ); cat.say(); //I'm cat console.log( Animal.name, //Animal Animal.color //back ); Animal.say(); //Animal.say is not a function new的内部原理1var cat = new Animal(\"cat\"); Animal 本身是一个普通函数，但当通过new来创建对象时，Animal 就是构造函数。 JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其内部流程如下： 123456new Animal('cat') = &#123; var obj = &#123;&#125;; obj.__proto__ = Animal.prototype; var result = Animal.call(obj,\"cat\"); return typeof result === 'object'? result : obj;&#125; 探索new的意义对 new 运算符有了较深入的理解之后，我们再回到开篇提到的问题：在JavaScript 中，万物皆对象，为什么还要通过 new 来产生对象？ 要弄明白这个问题，我们首先要搞清楚 cat 和 Animal 的关系： cat继承了Animal对象 cat就是Animal的实例 因此，通过 new 创建的 对象 和 构造函数 之间建立了一条原型链，原型链的建立，让原本孤立的对象有了依赖关系和继承能力，让JavaScript 对象能以更合适的方式来映射真实世界里的对象，这是面向对象的本质。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"scrollTop等元素距离","slug":"scrollTop","date":"2018-04-05T12:33:30.000Z","updated":"2018-05-31T13:14:31.634Z","comments":true,"path":"2018/04/05/scrollTop/","link":"","permalink":"http://yoursite.com/2018/04/05/scrollTop/","excerpt":"","text":"scrollTop等元素距离 window与document window1.window对象表示浏览器中打开的窗口。2.window对象可以省略，如:alert() 等价于 window.alert() document1.document对象是window对象的一部分。如：document.body 等价于 window.document.body2.浏览器的html文档成为document对象。 window对象window.innerWidth与window.outerWidthwindow.innerWidth（打开窗口的内部宽度）与window.outerWidth（打开窗口的外部宽度） window.innerHeight与window.outerHeightwindow.innerHeight（打开窗口的内部高度）与window.outerHeight（打开窗口的外部高度） window.screen.width与window.screen.availWidthwindow.screen.availWidth 属性表示可利用宽度，通常和window.scree.width同值。 window.screen.height与window.screen.availHeightwindow.screen.availHeight 属性得到的值通常比window.screen.height 属性的值小一个系统任务栏的高度； window.screenTop与window.sreenLeftwindow.screenTop和window.sreenLeft 分别表示浏览器顶部距离屏幕顶部的距离和浏览器左侧距离屏幕左侧的距离。 document对象clientWidth与clientHeight元素的宽度和高度，包括padding，但不包括border, margin和滚动条。 offsetWidth与offsetHeight元素的高度或宽度，包括元素的边框、内边距和滚动条，不包括margin 。 scrollWidth与scrollHeight返回元素内容的整体尺寸，包括元素看不见的部分（需要滚动才能看见的）。返回值包括padding 和滚动条，但不包括margin和border。 scrollTop和scrollLeft要确定的这两个属性的值，首先得确定元素的offsetParent。offsetParent指的是距该元素最近的position不为static的祖先元素，如果没有则指向body元素。确定了offsetParent，offsetLeft指的是元素左侧偏移offsetParent的距离，同理offsetTop指的是上侧偏移的距离。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Flex布局","slug":"flex","date":"2018-04-05T12:33:30.000Z","updated":"2018-05-31T13:03:09.440Z","comments":true,"path":"2018/04/05/flex/","link":"","permalink":"http://yoursite.com/2018/04/05/flex/","excerpt":"","text":"Flex布局Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: column-reverse | column | row（默认值） | row-reverse;&#125; flex-warp默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap（默认值） | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start（默认值） | flex-end | center | space-between | space-around;&#125; align-itemsalign-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch（默认值）;&#125; align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch（默认值）;&#125; 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto（默认值） | flex-start | flex-end | center | baseline | stretch;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"http://yoursite.com/tags/Flex/"}]},{"title":"Event Loop","slug":"Event Loop","date":"2018-04-02T12:33:30.000Z","updated":"2018-05-31T13:27:33.194Z","comments":true,"path":"2018/04/02/Event Loop/","link":"","permalink":"http://yoursite.com/2018/04/02/Event Loop/","excerpt":"","text":"事件循环单线程众所周知，JavaScript是单线程的。 所谓单线程，指的是在JS引擎中负责解释和执行JavaScript代码的线程只有一个主线程。 但是实际上还存在其他的线程，例如：处理AJAX的线程、处理DOM事件的线程、定时器线程等。可以把它们称为工作线程。 同步和异步同步：如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。例如： 12Math.sqrt(2);console.log('Hi'); 异步：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。例如： 123fs.readFile('foo.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;); 异步过程的构成要素异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。 一个异步过程通常是这样的： 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。 异步函数通常具有以下的形式： 1A(args..., callbackFn) 它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。args是这个函数需要的参数。callbackFn也是这个函数的参数，但是它比较特殊所以单独列出来。 所以，从主线程的角度看，一个异步过程包括下面两个要素： 发起函数(或叫注册函数)A 回调函数callbackFn 它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 注意：前面说的形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如： 1234var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open(&apos;GET&apos;, url);xhr.send(); // 发起函数 发起函数和回调函数就是分离的。 异步执行的运行机制1234567（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 只要执行栈（同步任务所加入的任务栈）中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子： 12345var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价: 12345var req = new XMLHttpRequest();req.open('GET', url); req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。 定时器注意：定时器也属于异步函数。定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。 12setTimeout(function()&#123;console.log(1);&#125;, 0);console.log(2); 上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。 事实上，定时器只是在规定时间之后，将事件添加进任务队列中等待主线程取回执行栈执行，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"数组去重","slug":"数组去重的方法","date":"2018-04-01T12:33:30.000Z","updated":"2018-05-31T13:32:12.643Z","comments":true,"path":"2018/04/01/数组去重的方法/","link":"","permalink":"http://yoursite.com/2018/04/01/数组去重的方法/","excerpt":"","text":"数组去重1.检测新数组中是否已存在12345678910function unArray(arr)&#123; let newArr = []; for(let i=0;i&lt;arr.length;i++) &#123; if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 2.检测原数组中是否有重复12345678910function unArray(arr)&#123; let newArr = []; for(let i=0;i&lt;arr.length;i++) &#123; if(arr.indexOf(arr[i]) == i)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 3.先排序再判断12345678910111213function unArray(arr)&#123; arr.sort(); let newArr = [arr[0]]; let first = arr[0]; for(let i=0;i&lt;arr.length;i++) &#123; if(arr[i] !== first)&#123; newArr.push(arr[i]); first = arr[i]; &#125; &#125; return newArr;&#125; 4.哈希表法123456789101112function unArray(arr)&#123; let newArr = []; let hash = &#123;&#125;; for(let i=0;i&lt;arr.length;i++) &#123; if(!hash[arr[i]])&#123; newArr.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return newArr;&#125; 5.ES6实现数组去重123let newArray = Array.from(new Set(arr));//或如下写法let newArray = [...new Set(arr)];","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"重绘和回流","slug":"回流和重绘","date":"2018-04-01T12:33:30.000Z","updated":"2018-05-31T13:30:06.459Z","comments":true,"path":"2018/04/01/回流和重绘/","link":"","permalink":"http://yoursite.com/2018/04/01/回流和重绘/","excerpt":"","text":"重绘和回流浏览器向服务器请求到了HTML文档后便开始解析，产物是DOM Tree（文档对象模型），如果有css，会根据css生成CSSOM（CSS对象模型），然后再由DOM和CSSOM合并产生Render Tree渲染树，有了渲染树，知道了所有节点的样式，便根据这些节点以及样式计算它们在浏览器中确切的大小和位置，这就是布局。最后把节点绘制到浏览器上。 重绘（repaint）当页面元素样式改变不影响元素在文档流中的位置时，浏览器会进行重绘操作，例如： 改变background-color 改变border-color 改变visibility 回流（reflow）当render tree中的一部分因为元素的规模尺寸、布局、隐藏等改变的时候，浏览器重新渲染部分或全部文档的过程。 何时发生回流？ 页面渲染初始化； 添加或者删除可见的DOM元素时； 元素的位置发生改变； 元素的尺寸发生改变（边距、填充、边框、宽度和高度）； 内容变化（例如在input框输入文字，或者文字、图片大小发生改变时）； 浏览器窗口尺寸改变（发生resize事件时）； 注意：回流必将引起重绘，而重绘不一定会引起回流。 性能优化回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系;浏览器本身能够进行优化，尽可能减少重绘和回流。 很多浏览器会维护一个队列，将所有会引起回流、重绘的操作放入到这个队列中，等到队列中的操作到了一定数量或者一定的时间间隔，浏览器就会flush队列，进行批处理，这样就会让多次回流、重绘变成一次回流或重绘。 不过，注意：当你向浏览器请求一些style信息的时候，就会让浏览器flush队列： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 当你请求如上属性时，浏览器为了给你最精确的值，需要立即flush队列。 如何减少重绘和回流？CSS中： 尽可能在DOM树的最末端改变class ； 动画效果应用到position属性为absolute或fixed 这类脱离了文档流的元素上。 牺牲平滑度换取速度； JS中： 避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性 ； 避免循环操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。 也可以在一个display:none的元素上进行操作，最终把它显示出来； 避免循环读取offsetLeft等属性。在循环之前把它们存起来；","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"深浅拷贝","slug":"深浅拷贝","date":"2018-04-01T12:33:30.000Z","updated":"2018-05-31T13:31:40.897Z","comments":true,"path":"2018/04/01/深浅拷贝/","link":"","permalink":"http://yoursite.com/2018/04/01/深浅拷贝/","excerpt":"","text":"深浅拷贝ECMAScript中的变量类型分为两种： 基本类型： undefined、null、Boolean、String、Number。 引用类型： 统称为Object类型，细分为：Object、Array、Date、Function等。 不同类型变量的存储方式基本数据类型基本数据类型保存在栈内存，形式如下：栈内存中分别存储着变量的标识符以及变量的值。 引用数据类型引用类型 保存在 堆内存 中， 栈内存存储的是变量的标识符以及对象在堆内存中的存储地址，当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从对应的堆内存中取得所需的数据。 什么是深浅拷贝对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。 而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。 基本数据类型的拷贝全部为深拷贝。 引用数据类型的拷贝： 浅拷贝： 深拷贝： 手动实现深拷贝1234567891011121314151617function deepClone(source)&#123; if(!source &amp;&amp; typeof source !== 'object')&#123; throw new Error('error arguments', 'shallowClone'); &#125; let targetObj = Array.isArray(source) ? [] : &#123;&#125;; for(let keys in source) &#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === 'object')&#123; targetObj[keys] = deepClone(source[keys]); &#125; else &#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; JS中的深拷贝可以通过JSON对象中的方法来实现深拷贝： 1234567function deepClone(source)&#123; if(!source &amp;&amp; typeof source !== 'object')&#123; throw new Error('error arguments', 'shallowClone'); &#125; let targetObj = JSON.parse(JSON.stringify(obj)); return targetObj;&#125; JS中的浅拷贝注意：Array对象中的slice()方法以及concat()方法看似深拷贝，其实是浅拷贝。 这两种方法都会深拷贝第一层的值，但是到达第二层的时候，全都变为浅拷贝。 例如： 123456var a = [1,2,3];var b = a.concat(); //concatconsole.log(b === a);a[0] = 4;console.log(a);console.log(b); 而第二层时： 123456var a = [[1,2,3],4,5];var b = a.slice();console.log(a === b);a[0][0] = 6;console.log(a);console.log(b); jQuery中的深浅拷贝可以使用jQuery中的extend方法来分别实现深浅拷贝。 12345function deepClone(source)&#123; let targetObj = $.extend(true, &#123;&#125;, sourse); //第一个参数为true表示深拷贝，若为false则表示浅拷贝，第二个参数为目标对象，而第三个参数为将要合成到目标对象上的对象。 return targetObj;&#125; 注意：无论extend函数中的第一个参数为true还是false，第一层的拷贝都一定是深拷贝，而第二层以上的拷贝则视第一个参数而定。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"多栏布局","slug":"多栏布局","date":"2018-03-25T12:33:30.000Z","updated":"2018-05-31T13:28:26.628Z","comments":true,"path":"2018/03/25/多栏布局/","link":"","permalink":"http://yoursite.com/2018/03/25/多栏布局/","excerpt":"","text":"多栏布局两栏布局BFC法123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;style&gt; .aside&#123; height: 200px; width: 100px; float: left; &#125; .main&#123; height: 200px; overflow: hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;diV id=\"content\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;/diV&gt; &lt;/body&gt;&lt;/html&gt; 如上代码实现步骤： 固定宽度的aside 先设置左浮动，此时右边的main会受到浮动的影响，所以要对它进行清除浮动。 为了不改变布局，那么就要使得main成为一个BFC，于是设置overflow:hidden 即可。 负边距法1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;style&gt; .center&#123; height: 200px; width: 100%; float: left; &#125; .content&#123; height: 200px; margin-right: 100px; &#125; .aside&#123; height: 200px; width: 100px; float: left; margin-left: -100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"main\"&gt; &lt;div class=\"center\"&gt; &lt;div class=\"content\"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如上代码实现步骤： 注意先将content用一层center包裹起来。 先将center的width设置为100%，然后让它左浮动。 为content设置margin-right: 100px （此处100px为aside元素的宽度） 设置aside元素的width，同时让它左浮动，再设置负边距margin-left: -100px 。 三栏布局绝对定位法12345678910111213141516171819202122232425262728&lt;html&gt; &lt;head&gt; &lt;style&gt; .left,.right&#123; position: absolute; top: 0px; height: 100%; &#125; .left&#123; left: 0px; width: 100px; &#125; .right&#123; right: 0px; width: 200px; &#125; .main&#123; margin: 0px 200px 0px 100px; height: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"main\"&gt;Main&lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浮动法1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;style&gt; .left&#123; float: left; width: 100px; &#125; .right&#123; float: right; width: 200px; &#125; .main&#123; margin: 0px 200px 0px 100px; height: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"main\"&gt;Main&lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 圣杯布局1234567891011121314151617181920212223242526272829303132333435&lt;html&gt; &lt;head&gt; &lt;style&gt; .left&#123; float: left; width: 150px; margin-left: -100%; position: relative; left: -150px; &#125; .right&#123; float: left; width: 190px; margin-left: -190px; position: relative; right: -190px; &#125; .main&#123; float: left; width: 100%; &#125; .center&#123; padding-left: 150px; padding-right: 190px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"center\"&gt; &lt;div class=\"main\"&gt;Main&lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如上代码实现步骤： 先将三栏全部左浮动 ，为main部分设置width: 100% 。（main部分需要放在文档最前边，以便先得到渲染） 给left部分和right部分设置margin值，使它们与main部分处在同一行。（不过这时main部分会被遮挡住） 为外围div设置padding ，使得现在三个部分总宽度等于main的最终宽度。 将left和right部设置为position: relative ，然后将它们移动到各自的位置上。 双飞翼布局12345678910111213141516171819202122232425262728293031&lt;html&gt; &lt;head&gt; &lt;style&gt; .left&#123; float: left; width: 150px; margin-left: -100%; &#125; .right&#123; float: left; width: 190px; margin-left: -190px; &#125; .content&#123; float: left; width: 100%; &#125; .main&#123; margin-left: 150px; margin-right: 190px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;Main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如上代码实现步骤：（前两步实现步骤与圣杯布局是一样的） 先将三栏全部左浮动 ，为content部分设置width: 100% 。（content部分需要放在文档最前边，以便先得到渲染） 给left部分和right部分设置margin值，使它们与content部分处在同一行。（不过这时content部分会被遮挡住） 给main部分添加margin即可。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"隐藏页面元素的方法","slug":"隐藏元素的方法","date":"2018-03-24T12:33:30.000Z","updated":"2018-05-31T13:32:45.006Z","comments":true,"path":"2018/03/24/隐藏元素的方法/","link":"","permalink":"http://yoursite.com/2018/03/24/隐藏元素的方法/","excerpt":"","text":"隐藏页面元素的方法opacityopacity 属性的意思是设置一个元素的透明度。它不是为改变元素的边界框（bounding box）而设计的。这意味着将 opacity 设为 0 只能从视觉上隐藏元素。而元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互。 123.hide &#123; opacity: 0;&#125; position假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。 12345.hide &#123; position: absolute; top: -9999px; left: -9999px;&#125; visibility将visibility的值设为 hidden 将隐藏我们的元素。如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。 123.hide &#123; visibility: hidden;&#125; displaydisplay 属性依照词义真正隐藏元素。将 display 属性设为 none 确保元素不可见并且连盒模型也不生成。使用这个属性，被隐藏的元素不占据任何空间。不仅如此，一旦 display 设为 none 任何对该元素直接打用户交互操作都不可能生效。这种方式产生的效果就像元素完全不存在。 123.hide &#123; display: none;&#125; display:none;与visibility:hidden;的区别 display:none会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible可以让子孙节点显式。 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"清除浮动","slug":"清除浮动","date":"2018-03-21T12:33:30.000Z","updated":"2018-05-31T13:30:59.783Z","comments":true,"path":"2018/03/21/清除浮动/","link":"","permalink":"http://yoursite.com/2018/03/21/清除浮动/","excerpt":"","text":"清除浮动浮动是什么？浮动元素会半脱离文档流并且向左/向右浮动，直到碰到父元素或者另一个浮动元素。 利用clear清除浮动应用clear属性的元素不允许它的左边/右边挨着清除浮动。它的原理是：在被清除浮动的元素上边或者下边添加足够的清除空间。 例如以下代码会造成高度坍塌： 12345678910111213141516.box-wrapper &#123; border: 5px solid red;&#125;.box-wrapper .box &#123; float: left; width: 100px; height: 100px; margin: 20px; background-color: green;&#125;&lt;div class=\"box-wrapper\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt; 使用clear清除浮动： 123456&lt;div class=\"box-wrapper\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 利用BFC清除浮动 若要利用BFC处理高度坍塌，则只需要使父元素称为BFC。 BFC的触发方式： ✦ float 为 left | right ✦ overflow 为 hidden | auto | scorll ✦ display 为 table-cell | table-caption | inline-block | flex | inline-flex ✦ position 为 absolute | fixed","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"cookie与WebStorage","slug":"cookie与WebStorage","date":"2018-03-21T12:33:30.000Z","updated":"2018-05-31T13:25:44.771Z","comments":true,"path":"2018/03/21/cookie与WebStorage/","link":"","permalink":"http://yoursite.com/2018/03/21/cookie与WebStorage/","excerpt":"","text":"cookie、sessionStorage、localStorage 详解Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。 cookiecookie是什么？简单来说，Cookie就是服务器暂存放在你的电脑里的资料（.txt格式的文本文件），好让服务器用来辨认你的计算机。当你在浏览网站的时候，Web服务器会先送一小小资料放在你的计算机上，Cookie 会把你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookie资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。目前Cookie最广泛的是记录用户登录信息，这样下次访问时可以不需要输入自己的用户名、密码了。 cookie的相关字段要表示唯一的一个cookie 需要三个值： name：一个唯一确定cookie的名称。 domain：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。 path：对于指定域中的那个路径，应该向服务器发送cookie。 cookie的缺点 cookie的数量和长度有限制，通常每个cookie大小不能超过4kb。 有的浏览器会清理很少使用的cookie 。 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 Web StorageWeb Storage是为了在本地“存储”数据而生。html5中的 Web Storage 包括了两种存储方式：sessionStorage和localStorage 。 注意：只要有效期和作用域，浏览器每次访问的时候都会将Storage载入到内存里。 local Storage localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 localStorage也受同源策略的限制。 session Storage sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁 local Storage和session Storage的相同点 localStorage和sessionStorage都具有相同的操作方法，如setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"DNS详解","slug":"DNS详解","date":"2018-03-16T12:33:30.000Z","updated":"2018-05-31T13:26:25.520Z","comments":true,"path":"2018/03/16/DNS详解/","link":"","permalink":"http://yoursite.com/2018/03/16/DNS详解/","excerpt":"","text":"DNS详解 1.什么是DNS？DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库 。由于DNS所以我们不用记住每个网页的IP地址，而只需要主机名就足够了。 通过主机名（域名）利用DNS最终得到对应IP的过程称为域名解析。 2.DNS的查询方式当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。 ①递归查询局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名（待查询域名）的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 ②迭代查询局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。 3.DNS域名称的空间组织方式","categories":[],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"}]},{"title":"JS中的Ajax","slug":"Ajax","date":"2018-03-08T12:33:30.000Z","updated":"2018-05-31T12:54:07.814Z","comments":true,"path":"2018/03/08/Ajax/","link":"","permalink":"http://yoursite.com/2018/03/08/Ajax/","excerpt":"","text":"JS中的AjaxAjax简介Ajax为 Asynchronous Javascript And XML 的缩写，这一技术能够向服务器请求额外的数据而无须卸载页面。 XMLHttpRequest对象创建XHR对象12var xhr = new XMLHttpRequest();//对于IE只支持IE7+ XHR的用法open()方法使用XHR对象时，要调用的第一个方法就是open() ，它接受3个参数：①要发送的请求的类型 ②请求的URL ③是否异步发送请求。 1xhr.open(\"get\", \"example.php\", false); 需要注意两点： 调用open()方法不会真正发送请求，而只是启动一个请求以备发送。 只能向一个域中使用相同端口和协议的URL发送请求，否则会出现跨域的安全问题。 send()方法要发送请求，必须使用send()方法： 12xhr.send(null)；//参数只有一个：作为请求主体发送的数据 XHR对象的属性XHR对象中的许多属性会在服务器收到响应之后被自动填充： responseText: 作为响应主体被返回的文本。 status: 响应的HTTP状态。 status: HTTP的状态说明。 readyState : 当前的活动阶段： 0：未初始化（尚未调用open()方法） 1： 启动（已调用open()方法，但尚未调用send()方法） 2： 发送（已调用send()方法，但尚未收到响应） 3： 接受（已经接受到部分响应数据） 4： 完成（已经接受到全部响应数据，并且已经可以在客户端使用） 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; //状态码在200~300之间一般表示成功，状态码为304表示请求的资源没有被修改，可以直接使用缓存 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"example.txt\", true);xhr.send(null); 注意：无论返回的内容类型是什么，响应主体的内容都会保存到responseText属性中。 HTTP的头部信息默认情况下，发送XHR请求的同时还会发送下列头部信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何Cookie。 Host: 发出请求的页面所在的域。 Referer：发出请求的页面的URI。 User-Agent：浏览器用户的代理字符串。 利用setRequestHeader()方法可以设置自定义的请求头部信息。注意：必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()方法。 示例如下： 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; //状态码在200~300之间一般表示成功，状态码为304表示请求的资源没有被修改，可以直接使用缓存 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"example.txt\", true);xhr.setRequestHeader(\"MyHeader\", \"MyValue\");xhr.send(null); GET请求注意：对XHR而言，位于传入open()方法的URL末尾的查询字符创必须经过正确的编码才行。 以下为向现有URL末尾添加查询字符串参数的辅助函数： 12345function addURLParam(url, name, value) &#123; url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&amp;\"); url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value); return url;&#125; POST请求POST请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。 123456789101112131415161718function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; //状态码在200~300之间一般表示成功，状态码为304表示请求的资源没有被修改，可以直接使用缓存 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125; &#125;; xhr.open(\"post\", \"example.txt\", true); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); var form = document.getElementById(\"user-info\"); //此处的serialize()函数用于表单序列化处理 xhr.send(serialize(form));&#125; 这样以后服务器端中的PHP就可以通过$_POST 超级全局变量访问提交的数据了。注意：如果不设置Content-Type头部信息，那么数据就不会出现在$_POST 超级全局变量中。","categories":[],"tags":[{"name":"JavaScript ajax","slug":"JavaScript-ajax","permalink":"http://yoursite.com/tags/JavaScript-ajax/"}]},{"title":"ES6学习笔记","slug":"ES6","date":"2018-03-07T12:33:30.000Z","updated":"2018-05-31T13:01:14.718Z","comments":true,"path":"2018/03/07/ES6/","link":"","permalink":"http://yoursite.com/2018/03/07/ES6/","excerpt":"","text":"ES6学习笔记ES6简介ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。 let和const命令let命令基本用法let的用法类似于var,但是所声明的变量，只在let命令所在的代码块内有效。（例如if语句和for语句）1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 以下为for循环中的示例：123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。1typeof undeclared_variable // \"undefined\" 这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？内层变量可能会覆盖外层变量12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 ####ES6的块级作用域let实际上为 JavaScript 新增了块级作用域：1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ####块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 注意：ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 ####do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。1234&#123; let t = f(); t = t * t + 1;&#125; 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。1234let x = do &#123; let t = f(); t * t + 1;&#125;; ###const命令 ####基本用法const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const声明的常量，也与let一样不可重复声明。 ####本质const实际上保证的是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，不保证数据结构是不是可变的。例如：12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-only 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 如果想将整个对象冻结，可以使用Object.freeze方法：12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; ###顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 函数的扩展基本用法ES6 之前，不能直接为函数的参数指定默认值，ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 参数变量是默认声明的，所以不能用let或const再次声明。 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; rest参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 1var f = v =&gt; v; 上面的箭头函数等同于： 123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 注意：函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 Module 的语法export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y;&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 同样的，function和class的输出，也必须遵守这样的写法。 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 import命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 .js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 1import &#123;myMethod&#125; from 'util'; 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。import命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 export default命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 需要注意的是，这时import命令后面，不使用大括号。 Promise对象Promise的含义Promise 是异步编程的一种解决方案。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 Promise对象有以下两个特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数: 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行: 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是一个用Promise对象实现的 Ajax 操作的例子: 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。 resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 : 123456789101112const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.protype.then()then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); Promise.protype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 注意：可以发现reject方法的作用，等同于抛出错误。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例。 p的状态由p1、p2、p3决定，分成两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 例如： 12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); Promise.resolve等价于下面的写法： 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; IteratorIterator(遍历器)的概念遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口。 使得数据结构的成员能够按某种次序排列。 Iterator 接口主要供for...of消费。 Iterator 的遍历过程： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 注意：每一次调用next方法，都会返回数据结构的当前成员的信息，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 默认Iterator接口原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 字符串的Iterator接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。 123456789var someString = \"hi\";typeof someString[Symbol.iterator]// \"function\"var iterator = someString[Symbol.iterator]();iterator.next() // &#123; value: \"h\", done: false &#125;iterator.next() // &#123; value: \"i\", done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; for…of循环一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 数组12345const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125; for...of循环可以代替数组实例的forEach方法。 123456const arr = ['red', 'green', 'blue'];arr.forEach(function (element, index) &#123; console.log(element); // red green blue console.log(index); // 0 1 2&#125;); JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。 123456789var arr = ['a', 'b', 'c', 'd'];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。 12345678910let arr = [3, 5, 7];arr.foo = 'hello';for (let i in arr) &#123; console.log(i); // \"0\", \"1\", \"2\", \"foo\"&#125;for (let i of arr) &#123; console.log(i); // \"3\", \"5\", \"7\"&#125; 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象： entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 对象对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。 1234567891011121314151617let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function Set和Map数据结构Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。 注意：两个对象总是不相等的： 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Set实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。 keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] 2.forEach() 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 WeaksetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象全都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。 语法123const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125; 123const b = [3, 4];const ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) Weakset实例的方法 WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 123456789101112const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet 没有size属性，没有办法遍历它的成员。 Weakset的一个用处由于Weakset对其中的对象弱引用，所以当处于需要用一个数组存储对象，但是又需要预防出现内存泄漏的场景（例如存储DOM节点）时可以使用此对象。 Map基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 123456const data = &#123;&#125;;const element = document.getElementById('myDiv');data[element] = 'metadata'//由于键值只接受字符串，所以element对象作为键值时已经被转换为“[object HTMLDivElement]”data['[object HTMLDivElement]'] // \"metadata\" 为了解决这个问题，ES6 提供了 Map 数据结构。Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现，“键”的范围不限于字符串。 123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 可以将一个Map实例内部看做[ [&#39;foo&#39;, 1], [&#39;bar&#39;, 2], [&#39;baz&#39;, 3] ] 来理解。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 如果读取一个未知的键，则返回undefined。 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 12345const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined//实际这是两个值 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 Map实例的属性和方法Map实例具有以下属性： Map.prototype.size：返回 Map 结构的成员总数。 set(key, value) ：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。 set方法返回的是当前的Map对象，因此可以采用链式写法： 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); get(key): get方法读取key对应的键值，如果找不到key，返回undefined 。 has(key): has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key) : delete方法删除某个键，返回true。如果删除失败，返回false。 clear() :clear方法清除所有成员，没有返回值。 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员 需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\" 上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 12map[Symbol.iterator] === map.entries// true","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"src与href的区别","slug":"src与href","date":"2018-02-15T12:33:30.000Z","updated":"2018-06-18T10:53:35.569Z","comments":true,"path":"2018/02/15/src与href/","link":"","permalink":"http://yoursite.com/2018/02/15/src与href/","excerpt":"","text":"src与href我们在平常在使用a标签和img标签时都知道应该分别使用href属性与src属性，但是这两者的作用看起来如此相近，为什么还要做出区别呢？ href诸如link标签与a标签等，使用的属性都是href属性。href属性的作用是：在指定的资源和当前元素之间建立连接（并不是要立即使用）。所以当浏览器从上到下解析文档时，并不会因为遇到href属性而阻塞进程。（而是例如开出一个新的工作线程去下载css文件） src而例如img与script元素等众多替换元素使用的都为src属性。src属性的全称为source（资源），表示的是引用资源，然后替换该元素（所以具有src属性的元素都为替换元素）。所以在加载具有src属性的元素时，将会造成进程的阻塞，停止解析文档，转而加载链接到的资源。这也是为什么说我们通常要把script标签放在body元素的末尾的原因（防止因为脚本而阻塞文档解析）。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"JS中的数据类型与操作符","slug":"typesOfJs","date":"2018-02-15T12:33:30.000Z","updated":"2018-05-31T13:17:09.708Z","comments":true,"path":"2018/02/15/typesOfJs/","link":"","permalink":"http://yoursite.com/2018/02/15/typesOfJs/","excerpt":"","text":"JS中的数据类型与操作符分类 基本数据类型： Undefined Null Boolean Number String 复杂数据类型： Object 特殊的值1234567891011121314151617//对于声明之后未赋值的变量，值为“undefined”var message;alert(typeof message); //\"undefined\"//对于尚未声明的变量，值也为“undefined”//var age;alert(typeof age); //\"undefined\"//对于值null，typeof的值为“object”var sky = null;alert(typeof sky); //\"object\"//对于函数，返回值为“function”function doSomething()&#123; //...&#125;alert(typeof doSomething); //\"function\" NaNNaN，即非数值（Not a Number）是一个特殊的数值。 特点 任何涉及NaN的操作（例如NaN/10）都会返回NaN。 NaN与任何值都不相等，包括它本身。 1alert(NaN == NaN); //false 数值转换Boolean()1234567Boolean(-1); //trueBoolean(3); //trueBoolean(0); //falseBoolean(NaN); //false Number()与parseInt()1234567891011121314Number(\"\"); //0Number(null); //0var tel;Number(tel); //NaNNumber(\"Hello world!\"); //NaNparseInt(\"\"); //NaNparseInt(\"1234blue\"); //1234parseInt(\"blue1234\"); //NaN toString()与String()基本上所有值都有toString()这个方法。（除了null, 和undefined） 而String()弥补了toString()的不足，它的转化规则为： 如果该值有toString()方法，则调用该方法并返回相应结果。 如果值是null， 则返回null。 如果值是undefined， 则返回undefined。 一元加和减操作符在对非数值应用一元加操作时，该操作符会像Number()函数一样对这个值执行转换： 12var s1 = \"01\";s1 = +s1; //1 双逻辑非同时使用两个逻辑非就会模拟Boolean()函数的行为： 12345alert(!!\"blue\") //truealert(!!0) //falsealert(!!NaN) //false 逻辑与需要注意： 如果第一个操作数是null，则返回null。 如果第一个操作数是NaN，则返回NaN。 如果第一个操作数是undefined，则返回undefined。 加操作符对于加法操作，如果两个操作数中有一个为String类型，而另一个不是，则会将另一个操作数也转换为String类型。 比较操作符1234567891011var result = \"Brick\" &lt; \"alphabet\"; //true//两个字符串比较，将会比较首字母的字符编码大小var result = \"23\" &lt; \"3\"; //truevar result = \"23\" &lt; 3; //false//若是字符串和数值进行比较，则会将这个字符串转换为数值之后再进行比较var result = \"a\" &lt; 3; //false//此处“a”被转换为了NaN//NaN与任何操作数进行比较时，结果都是false 相等操作符 对于相等和不相等（==），将会先转换再比较，而对于全等和不全等（===），仅比较而不转换。 null和undefined是相等的。 比较相等性之前，不能将null和undefined 转换为其他任何值 如果有一个操作数为NaN，则对于相等操作符返回false （包括另一个操作数也是NaN），对不等操作符返回true。 注意：switch语句中比较的是进行全等比较而不是相等比较。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Fetch API学习笔记","slug":"FetchAPI","date":"2018-02-08T12:33:30.000Z","updated":"2018-05-31T12:39:58.680Z","comments":true,"path":"2018/02/08/FetchAPI/","link":"","permalink":"http://yoursite.com/2018/02/08/FetchAPI/","excerpt":"","text":"Fetch API学习笔记Fetch是一个现代的概念, 等同于 XMLHttpRequest。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。 示例在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。 123456789101112fetch(&quot;/data.json&quot;).then(function(res) &#123; // res instanceof Response == true. if (res.ok) &#123; res.json().then(function(data) &#123; console.log(data.entries); &#125;); &#125; else &#123; console.log(&quot;Looks like the response wasn&apos;t perfect, got status&quot;, res.status); &#125;&#125;, function(e) &#123; console.log(&quot;Fetch failed!&quot;, e);&#125;); Fetch引入了3个接口，它们分别是 Headers,Request 以及 Response 。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。 HeadersHeaders接口是一个简单的多映射的名-值表： 12345var content = \"Hello World\";var reqHeaders = new Headers();reqHeaders.append(\"Content-Type\", \"text/plain\");reqHeaders.append(\"Content-Length\", content.length.toString());reqHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以传一个多维数组或者json： 12345reqHeaders = new Headers(&#123; \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\",&#125;); Headers的内容可以被检索： 12345678910console.log(reqHeaders.has(\"Content-Type\")); // trueconsole.log(reqHeaders.has(\"Set-Cookie\")); // falsereqHeaders.set(\"Content-Type\", \"text/html\");reqHeaders.append(\"X-Custom-Header\", \"AnotherValue\");console.log(reqHeaders.get(\"Content-Length\")); // 11console.log(reqHeaders.getAll(\"X-Custom-Header\")); // [\"ProcessThisImmediately\", \"AnotherValue\"]reqHeaders.delete(\"X-Custom-Header\");console.log(reqHeaders.getAll(\"X-Custom-Header\")); // [] RequestRequest接口定义了通过HTTP请求资源的request格式。 最简单的 Request 是一个URL，可以通过URL来GET一个资源。 123var req = new Request(\"/index.html\");console.log(req.method); // \"GET\"console.log(req.url); // \"http://example.com/index.html\" URL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json： 1234567var uploadReq = new Request(\"/uploadImage\", &#123; method: \"POST\", headers: &#123; \"Content-Type\": \"image/png\", &#125;, body: \"image data\"&#125;); mode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为same-origin，no-cors（默认）以及cors。 same-origin模式：如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。 no-cors模式允许来自CDN的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的method只能是HEAD,GET或者POST。 cors模式我们通常用作跨域请求来从第三方提供的API获取数据。 ResponseResponse实例通常在fetch()的回调中获得。 Response中最常见的成员: status：默认值为200 status Text：默认值为OK ok：当status为2xx时它的值为true 这篇学习笔记参考这个API很“迷人”——(新的Fetch API))，有的部分没有立即理解，留待实践之后回头补充。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CodeIgniter Rest Server 学习笔记","slug":"CodeIgniter-Rest-Server","date":"2018-02-08T12:33:30.000Z","updated":"2018-05-31T12:59:23.777Z","comments":true,"path":"2018/02/08/CodeIgniter-Rest-Server/","link":"","permalink":"http://yoursite.com/2018/02/08/CodeIgniter-Rest-Server/","excerpt":"","text":"CodeIgniter Rest Server 学习笔记什么是CodeIgniter Rest Server？利用一个库文件、一个配置文件以及一个控制器就可以实现完整的CodeIgniter开发RESTful架构API的一个工具。 Installation只需要向CodeIgniter文件夹中的composer.json文件添加一下代码： 1\"chriskacerguis/codeigniter-restserver\": \"^3.0\" 然后运行一下命令安装依赖包： 1composer install Handling Requests当你的控制器继承REST_Controller 的时候，这个控制器中的方法名之后应该跟着HTTP请求动词，例如： 12345678910111213require 'application/vendor/autoload.php';class Books extends REST_Controller&#123; public function index_get() &#123; // Display all books &#125; public function index_post() &#123; // Create a new book &#125;&#125; 对于PUT、GET、POST等HTTP请求动词，可以通过以下方法来获取参数： 123$this-&gt;get('blah'); // GET param$this-&gt;post('blah'); // POST param$this-&gt;put('blah'); // PUT param 而对于DELETE请求，则只能通过在方法中添加参数，然后通过URL传入参数，来进行访问： 123456public function index_delete($id)&#123; $this-&gt;response([ 'returned from delete:' =&gt; $id, ]);&#125; 无论请求是否为GET请求，只要是通过URL传入的参数，都可以通过以下方法获取参数： 1$this-&gt;query('blah'); // Query param Responses可以通过类提供的response()方法来返回任意数据： 1234public function index_get()&#123; $this-&gt;response($this-&gt;db-&gt;get('books')-&gt;result());&#125; 若成功返回，那么它将会自动带上一个HTTP 200 OK 状态码，你也可以通过response() 方法的第二个参数来自定义返回的状态码： 12345public function index_post() &#123; // ...create new book $this-&gt;response($book, 201); // Send an HTTP 201 Created &#125; 如果你没有设置一个自定义的状态码，并且返回的数据出错了（空数组或者是空串），那么状态码将会被自动设置为404 Not Found ： 1$this-&gt;response([]); // HTTP 404 Not Found","categories":[],"tags":[{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"http://yoursite.com/tags/CodeIgniter/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"RESTful学习笔记","slug":"RESTful","date":"2018-02-06T12:33:30.000Z","updated":"2018-05-31T13:11:37.440Z","comments":true,"path":"2018/02/06/RESTful/","link":"","permalink":"http://yoursite.com/2018/02/06/RESTful/","excerpt":"","text":"RESTful学习笔记RESTful是什么？它的本质是一种软件架构风格，核心是面向资源（面向资源去设计API），它解决的问题有：①降低开发的复杂性②提高系统的可伸缩性。 设计概念和准则 网络上所有事物都可以被抽象为资源 每个资源都有唯一的资源标识，对资源的操作不会改变这些标识（例如对某一资源进行删除操作，删除完成后，它的资源标识还是有效的，只不过这个资源标识代表的资源不存在了） 所有的操作都是无状态的（前一次操作和后一次操作没有关联） HTTP协议URLHTTP是属于应用层的协议，特点是简洁、快速。 schema://host[:port]/path[?query-string][#anchor] scheme ：指定低层使用的协议（例如：http, https, ftp） host ：服务器的IP地址或者域名 port ：服务器端口，默认为80 path：访问资源的路径 query-string ：发送给http服务器的数据 anchor: 锚 请求组成格式：请求行、消息报头、请求正文 请求行格式：Method Request-URI HTTP-Version CRLF Method ：请求方法 Request-URI：请求路径 HTTP-Version: HTTP协议版本号 示例：GET/HTTP/1.1CRLF 请求方法 GET ：请求获取Request-URL所标识的资源 POST：在Request-URI所标识的资源后附加新的数据 HEAD：请求获取由Request-URI所标识的资源的响应信息报头（比如获取资源创建时间与最后修改时间等） PUT：请求服务器存储一个资源，并用Request-URI作为其标识（常用于更新） DELETE：请求服务器删除Request-URI所标识的资源 OPTIONS：查询服务器性能 响应组成格式：状态行、消息报头、响应正文 状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF 例如：HTTP/1.1 200 OK 状态码 200 OK ：客户端请求成功 400 Bad Request : 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized ：服务器收到请求，但是拒绝服务（无权限等） 404 Not Found ：请求资源不存在 500 Internal Server Error ：服务器发生不可预期的错误 503 Server Unavailable : 服务器当前不能处理客户端的请求（性能达到瓶颈等） RESTful设计要素如何设计RESTful API资源路径（URI）在RESTful架构中，每个网址代表一种资源，所以网址中不能有动词，只能有名词。一般来说API中的名词应该使用复数。 例如： 12//获取动物园资源，其中 v1 是版本号https://api.example.com/v1/zoos HTTP动词对于资源的操作（CURD），由HTTP动词表示。 GET：获取服务器资源 POST：创建新的服务器资源 PUT：更新完成后返回整条记录 DELETE：删除某个服务器资源 PATCH：更新完成后返回改变的属性 过滤信息如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 例如： ?offset=10 ：指定返回记录的开始位置 ?sortby=name&amp;order=asc：指定返回结果排序，以及排序顺序 状态码服务器向用户返回的状态码和提示信息，使用标准HTTP状态码。 200 OK：服务器成功返回用户请求的数据 201 CREATED ：新建或修改数据成功 204 NO CONTENT：删除数据成功 400 BAD REQUEST：用户发出的请求有错误 401 Unauthorized：表示用户没有认证，无法进行当前操作（没有提供认证参数） 403 Forbidden：表示用户访问是被禁止的（权限不足或认证参数错误等） 422 Unprocesable：当创建一个对象时，发生一个验证错误（创建新资源时，未提供所有所需字段等） 500 INTERNAL SERVER ERROR ：服务器发生错误，用户无法判断发出的请求是否成功 错误处理如果状态码是4XX或者5XX ，就应该向用户返回出错信息。一般来说，返回信息中将error作为键名，出错 信息作为键值即可： 123&#123; \"error\" : \"参数错误\"&#125; 返回结果针对不同的操作，服务器向用户返回的结果应该符合以下规范： GET /collections ：返回资源对象的列表（数组） GET /collections/identity ：返回单个资源对象 POST /collections ：返回新生成的资源对象 PUT /collections/identity：返回完整的资源对象 PATCH /collections/identity ：返回被修改的属性 DELETE/collections/identity ：返回一个空文档","categories":[],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://yoursite.com/tags/RESTful/"}]},{"title":"CodeIgniter学习笔记","slug":"CodeIgniter","date":"2018-02-05T12:33:30.000Z","updated":"2018-05-31T12:57:16.902Z","comments":true,"path":"2018/02/05/CodeIgniter/","link":"","permalink":"http://yoursite.com/2018/02/05/CodeIgniter/","excerpt":"","text":"CodeIgniter学习笔记概览应用程序流程图 index.php 文件作为前端控制器，初始化运行 CodeIgniter 所需的基本资源； Router 检查 HTTP 请求，以确定如何处理该请求； 如果存在缓存文件，将直接输出到浏览器，不用走下面正常的系统流程； 在加载应用程序控制器之前，对 HTTP 请求以及任何用户提交的数据进行安全检查； 控制器加载模型、核心类库、辅助函数以及其他所有处理请求所需的资源； 最后一步，渲染视图并发送至浏览器，如果开启了缓存，视图被会先缓存起来用于 后续的请求。 模型-视图-控制器CodeIgniter 的开发基于 MVC（模型-视图-控制器）设计模式。MVC 是一种 用于将应用程序的逻辑层和表现层分离出来的软件方法。在实践中，由于这种分离 所以你的页面中只包含很少的 PHP 脚本。 模型 代表你的数据结构。通常来说，模型类将包含帮助你对数据库进行增删改查的方法。 视图 是要展现给用户的信息。一个视图通常就是一个网页，但是在 CodeIgniter 中， 一个视图也可以是一部分页面（例如页头、页尾），它也可以是一个 RSS 页面， 或其他任何类型的页面。 控制器 是模型、视图以及其他任何处理 HTTP 请求所必须的资源之间的中介，并生成网页。 常规主题CodeIgniter URLCodeIgniter 中的 URL 被设计成对搜索引擎和人类友好，使用基于段的写法： 1example.com/news/article/my_article URI 分段1example.com/class/function/ID 第一段表示要调用的控制器 类 ； 第二段表示要调用的类中的 函数 或 方法 ； 第三段以及后面的段代表传给控制器的参数，如 ID 或其他任何变量； 移除URL中的index.php默认情况，你的 URL 中会包含 index.php 文件: 1example.com/index.php/news/article/my_article 你可以简单的通过一个 .htaccess 文件再加上一些简单的规则就可以移除 index.php ： 1234RewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ index.php/$1 [L] 在上面的例子中，除已存在的目录和文件，其他的 HTTP 请求都会经过你的 index.php 文件。 启用查询字符串有些时候，你可能更喜欢使用查询字符串格式的 URL: 1index.php?c=products&amp;m=view&amp;id=345 可以在 application/config.php 配置文件中启用它。 打开配置文件，查找下面这几项: 123$config['enable_query_strings'] = FALSE;$config['controller_trigger'] = 'c';$config['function_trigger'] = 'm'; 只要把 enable_query_strings 参数设为 TRUE 即可启用该功能。然后通过你设置的 trigger 关键字来访问你的控制器和方法: 1index.php?c=controller&amp;m=method 控制器什么是控制器？简而言之，一个控制器就是一个类文件，是以一种能够和 URI 关联在一起的方式来命名的。 文件名必须是大写字母开头，如：Blog.php，同时类名必须以大写字母开头。 另外，一定要确保控制器继承了父控制器类，这样它才能使用父类的方法。 定义默认控制器CodeIgniter 可以设置一个默认的控制器，当 URI 没有分段参数时加载，例如当用户直接访问你网站的首页时： 12//文件位于application/config/routes.php$route['default_controller'] = 'blog'; 重映射方法URI 的第二段通常决定控制器的哪个方法被调用。CodeIgniter 允许你使用 _remap() 方法来重写该规则，即定义自己的路由规则: 123456789101112//方法名之后的所有其他段都会作为参数传递进去public function _remap($method)&#123; if ($method === 'some_method') &#123; $this-&gt;$method(); &#125; else &#123; $this-&gt;default_method(); &#125;&#125; 注意：如果你的控制包含一个 _remap() 方法，那么无论 URI 中包含什么参数时都会调用该方法。 构造函数如果你打算在你的控制器中使用构造函数，你 必须 将下面这行代码放在里面: 1parent::__construct(); 原因是你的构造函数将会覆盖父类的构造函数，所以我们要手工的调用它。 视图简单来说，一个视图其实就是一个 Web 页面，或者页面的一部分，像页头、页脚、侧边栏等。 视图不是直接被调用的，它必须通过控制器来加载。 加载视图1$this-&gt;load-&gt;view('name'); name 参数为你的视图文件名。 注意：文件的扩展名 .php 可以省略，除非你使用了其他的扩展名。 加载多个视图CodeIgniter 可以智能的处理在控制器中多次调用 $this-&gt;load-&gt;view() 方法。 如果出现了多次调用，视图会被合并到一起。 向视图添加动态数据通过视图加载方法的第二个参数可以从控制器中动态的向视图传入数据， 这个参数可以是一个 数组或者一个 对象 。这里是使用数组的例子: 1234567$data = array( 'title' =&gt; 'My Title', 'heading' =&gt; 'My Heading', 'message' =&gt; 'My Message');$this-&gt;load-&gt;view('blogview', $data); 这里是使用对象的例子: 12$data = new Someclass();$this-&gt;load-&gt;view('blogview', $data); 注意：当你使用对象时，对象中的变量会转换为数组元素。 将视图作为数据返回加载视图方法有一个可选的第三个参数可以让你修改它的默认行为，它让视图作为字符串返回而不是显示到浏览器中，如果你需要返回的数据， 记住将它赋值给一个变量: 1$string = $this-&gt;load-&gt;view('myfile', '', TRUE); 模型什么是模型？模型是专门用来和数据库打交道的 PHP 类。 剖析模型模型类的基本原型如下: 123456789class Model_name extends CI_Model &#123; public function __construct() &#123; parent::__construct(); // Your own constructor code &#125;&#125; 加载模型你的模型一般会在你的控制器方法中加载并调用，加载之后，你就可以通过一个和你的类同名的对象访问模型中的方法： 123$this-&gt;load-&gt;model('model_name');$this-&gt;model_name-&gt;method(); 如果你想将你的模型对象赋值给一个不同名字的对象，你可以使用 $this-&gt;load-&gt;model() 方法的第二个参数: 123$this-&gt;load-&gt;model('model_name', 'foobar');$this-&gt;foobar-&gt;method(); 链接数据库当模型加载之后，它 并不会 自动去连接你的数据库。 你可以设置第三个参数为 TRUE 让模型在加载时自动连接数据库，会使用你的数据库配置文件中的配置: 1$this-&gt;load-&gt;model('model_name', '', TRUE); 还可以通过第三个参数传一个数据库连接配置: 12345678910$config['hostname'] = 'localhost';$config['username'] = 'myusername';$config['password'] = 'mypassword';$config['database'] = 'mydatabase';$config['dbdriver'] = 'mysqli';$config['dbprefix'] = '';$config['pconnect'] = FALSE;$config['db_debug'] = TRUE;$this-&gt;load-&gt;model('model_name', '', $config); 辅助函数每个辅助函数文件都是某一类 函数的集合。例如， URL 辅助函数 帮助我们创建链接，表单 辅助函数帮助我们创建表单元素，本文辅助函数 帮助我们处理文本的格式化，Cookie 辅助函数 帮助我们读取或设置 Cookie ，文件 辅助函数 帮助我们处理文件，等等等等。 辅助函数没有使用面向对象的方式来实现的。 它们是简单的过程式函数，每个函数处理一个特定的任务，不依赖于其他的函数。 加载辅助函数可以使用下面的方法简单的加载辅助函数: 1$this-&gt;load-&gt;helper('name'); name 参数为辅助函数的文件名，去掉 .php 文件后缀以及 _helper 部分。 辅助函数可以在你的控制器方法的任何地方加载（甚至可以在你的视图文件中加载，尽管这不是 个好的实践），只要确保在使用之前加载它就可以了。 加载多个辅助函数如果需要加载多个辅助函数，可以使用一个数组： 123$this-&gt;load-&gt;helper( array('helper1', 'helper2', 'helper3')); 使用CodeIgniter类库在使用之前， 你要先在控制器中初始化它： 1$this-&gt;load-&gt;library('form_validation'); 同样，多个类库可以通过一个数组来同时加载。 1$this-&gt;load-&gt;library(array('email', 'table')); 使用CodeIgniter驱动器驱动器是一种特殊类型的类库，它有一个父类和任意多个子类。子类可以访问父类， 但不能访问兄弟类。 要使用一个驱动器，你可以在控制器中使用下面的方法来进行初始化: 1$this-&gt;load-&gt;driver('class_name'); 然后就可以像下面这样调用该类的方法: 1$this-&gt;some_parent-&gt;some_method(); 而对于那些子类，我们不用初始化，可以直接通过父类调用了: 12$this-&gt;some_parent-&gt;child_one-&gt;some_method();$this-&gt;some_parent-&gt;child_two-&gt;another_method(); URI路由通配符一个典型的使用通配符的路由规则如下: 1$route['product/:num'] = 'catalog/product_lookup'; 上面的例子中，如果 URL 的第一段是字符串 “product” ，第二段是个数字，那么， 将调用 “catalog” 类的 “product_lookup” 方法。 (:num) 匹配只含有数字的一段。 (:any) 匹配含有任意字符的一段。（除了 ‘/‘ 字符，因为它是段与段之间的分隔符） 注意：通配符实际上是正则表达式的别名，:any 会被转换为 [^/]+ ， :num 会被转换为 [0-9]+ 。 示例： 1$route['product/(:num)'] = 'catalog/product_lookup_by_id/$1'; URL 的第一段是 product ，第二段是数字时，将重定向到 catalog类的 product_lookup_by_id 方法，并将第二段的数字作为参数传递给它。 正则表达式一个典型的使用正则表达式的路由规则看起来像下面这样: 1$route['products/([a-z]+)/(\\d+)'] = '$1/id_$2'; 回调函数你可以在路由规则中使用回调函数来处理逆向引用。例如: 1234$route['products/([a-zA-Z]+)/edit/(\\d+)'] = function ($product_type, $id)&#123; return 'catalog/product_edit/' . strtolower($product_type) . '/' . $id;&#125;; 在路由中使用HTTP动词还可以在你的路由规则中使用 HTTP 动词（请求方法），当你在创建 RESTful 应用时特别有用。 你可以使用标准的 HTTP 动词（GET、PUT、POST、DELETE、PATCH），也可以使用自定义的动词 （例如：PURGE），不区分大小写。你需要做的就是在路由数组后面再加一个键，键名为 HTTP 动词。例如: 1$route['products']['put'] = 'product/insert'; 12//当发送 DELETE 请求到第一段为 \"products\" ，第二段为数字这个 URL时，将会调用 Product::delete() 方法，并将数字作为第一个参数。$route['products/(:num)']['DELETE'] = 'product/delete/$1'; 网页缓存 依靠网页缓存， 你的网页可以达到近乎静态网页的加载速度，因为程序的输出结果 已经保存下来了。 缓存是如何工作的？可以针对到每个独立的页面进行缓存，并且你可以设置每个页面缓存的更新时间。 当页面第一次加载时，缓存将被写入到 application/cache 目录下的文件中去。 开启缓存将下面的代码放到任何一个控制器的方法内，就可开启缓存: 12//其中 $n 是缓存更新的时间（单位分钟）$this-&gt;output-&gt;cache($n); 删除缓存如果你不再需要缓存某个页面，你可以删除掉该页面上的缓存代码，可以使用 delete_cache() 方法: 12345// Deletes cache for the currently requested URI$this-&gt;output-&gt;delete_cache();// Deletes cache for /foo/bar$this-&gt;output-&gt;delete_cache('/foo/bar'); 管理你的应用程序重命名应用程序目录如果你想重命名应用程序目录，你只需在重命名之后打开 index.php 文件将 $application_folder 变量改成新的名字: 1$application_folder = 'application'; 在视图文件中使用PHP替代语法如果你不使用 CodeIgniter 的模板引擎， 那么你就只能在视图文件中使用纯 PHP 语法了。 Echo替代语法通常情况，你会使用下面的方法来打印一个变量: 1&lt;?php echo $variable; ?&gt; 使用替代语法，你可以写成这样: 1&lt;?=$variable?&gt; 控制结构替代语法以下为foreach 的例子： 123456789&lt;ul&gt;&lt;?php foreach ($todo as $item): ?&gt; &lt;li&gt;&lt;?=$item?&gt;&lt;/li&gt;&lt;?php endforeach; ?&gt;&lt;/ul&gt; 注意这里没有任何括号。 以下为 if/elseif/else 的例子： 12345678910111213&lt;?php if ($username === 'sally'): ?&gt; &lt;h3&gt;Hi Sally&lt;/h3&gt;&lt;?php elseif ($username === 'joe'): ?&gt; &lt;h3&gt;Hi Joe&lt;/h3&gt;&lt;?php else: ?&gt; &lt;h3&gt;Hi unknown user&lt;/h3&gt;&lt;?php endif; ?&gt; 距离我上次写php可能已经差不多有一年了，而对于这个CodeIgniter框架，虽然我当时也只会皮毛，但是重新粗略看了一遍文档后发现有的地方更好理解了，也算是一种进步吧。。。这篇学习笔记可以算的上是从文档中取出来的简单入门教程，虽然完全不够面面俱到，同时对各种类库以及辅助函数等都没有涉及，只能留待用到的时候自行查阅，但是在某些基本的内容上倒是可以作为查阅资料。","categories":[],"tags":[{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"http://yoursite.com/tags/CodeIgniter/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"less学习笔记","slug":"less","date":"2018-02-02T12:33:30.000Z","updated":"2018-05-31T13:05:56.354Z","comments":true,"path":"2018/02/02/less/","link":"","permalink":"http://yoursite.com/2018/02/02/less/","excerpt":"","text":"less学习笔记导入可以通过下面的形势引入 .less 文件, .less 后缀可带可不带: 12@import \"lib.less\";@import \"lib\"; 如果导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就行： 1@import \"lib.css\"; 变量less的变量和sass的变量类似（使用@而不是$），但是相比之下缺少默认变量（!default）、特殊变量（将变量值作为属性值）和多值变量 ： 1234@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;#header &#123; color: @light-blue; &#125; 也可以用变量名定义为变量: 123@fnord: \"I am fnord.\";@var: 'fnord';content: @@var; 嵌套less 可以让我们以嵌套的方式编写层叠样式，同时与sass一样，less也可以在选择器嵌套中使用&amp;表示父元素选择器。 1234567891011#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &amp;:hover &#123; text-decoration: none &#125; &#125;&#125; 不过less没有sass中的属性嵌套的功能。 混合不同于sass中使用@mixin声明混合，然后再通过@include调用，在less中只需直接把需要声明为混合的属性集作为一个class，然后在需要的地方直接调用该class。 无参数12345678910111213.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #111; .bordered;&#125;.post a &#123; color: red; .bordered;&#125; 有参数123456789101112.border-radius (@radius) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125;#header &#123; .border-radius(4px);&#125;.button &#123; .border-radius(6px); &#125; 也可以设置默认值： 12345.border-radius (@radius: 5px) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125; 也可以定义不带参数属性集合,这样的好处是隐藏这个属性集合，不让它暴露到CSS中去，同时还能在其他的属性集合中引用： 12345678.wrap () &#123; text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;&#125;pre &#123; .wrap &#125; @arguments 变量@arguments包含了所有传递进来的参数 。如果你想单独处理每一个参数的话就可以像这样写: 123456.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123; box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;&#125;.box-shadow(2px, 5px) 将会输出： 123box-shadow: 2px 5px 1px #000;-moz-box-shadow: 2px 5px 1px #000;-webkit-box-shadow: 2px 5px 1px #000; 模式匹配和导引表达式模式匹配有些情况下，我们想根据传入的参数来改变混合的默认呈现，如果想让.mixin根据不同的@switch值而表现各异，如下这般设置： 123456789.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;.mixin (@_, @color) &#123; display: block;&#125; 现在，如果运行: 12345@switch: light;.class &#123; .mixin(@switch, #888);&#125; 就会得到下列CSS: 12345.class &#123; color: #a2a2a2; //第三个mixin任何参数都能匹配到 display: block;&#125; 我们也可以匹配多个参数： 123456.mixin (@a) &#123; color: @a;&#125;.mixin (@a, @b) &#123; color: fade(@a, @b);&#125; 引导当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。 12345678910.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;//匹配所有.mixin (@a) &#123; color: @a;&#125; 引序列使用逗号,—分割，当且仅当所有条件都符合时，才会被视为匹配成功。 1.mixin (@a) when (@a &gt; 10), (@a &lt; -10) &#123; ... &#125; 导引可以无参数，也可以对参数进行比较运算： 1234567@media: mobile;.mixin (@a) when (@media = mobile) &#123; ... &#125;.mixin (@a) when (@media = desktop) &#123; ... &#125;.max (@a, @b) when (@a &gt; @b) &#123; width: @a &#125;.max (@a, @b) when (@a &lt; @b) &#123; width: @b &#125; 如果想基于值的类型进行匹配，我们就可以使用is*函式： 12.mixin (@a, @b: 0) when (isnumber(@b)) &#123; ... &#125;.mixin (@a, @b: black) when (iscolor(@b)) &#123; ... &#125; 最后，在导引序列中可以使用and关键字实现与条件： 1.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) &#123; ... &#125; 使用not关键字实现或条件 1.mixin (@b) when not (@b &gt; 0) &#123; ... &#125; 运算less和sass中的运算并没有什么差别： 12//在复合属性中进行运算border: (@width * 2) solid black; 命名空间有时候，为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 你可以像下面这样在#bundle中定义一些属性集之后可以重复使用（可以理解为混合的集合）: 12345678910#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 例如需要引入.button ： 1234#header a &#123; color: orange; #bundle &gt; .button;&#125; 作用域less和lass不同，确实是存在局部作用域的： 123456789101112@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;#footer &#123; color: @var; // red &#125; 字符串插值变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构: 12@base-url: \"http://assets.fnord.com\";background-image: url(\"@&#123;base-url&#125;/images/bg.png\"); JavaScript 表达式JavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用: 1@var: `\"hello\".toUpperCase() + '!'`; 它也可以访问JavaScript环境: 1@height: `document.body.clientHeight`; 这篇学习笔记是我该文档 写的，在这之前我先去了解了sass，同时在学习less的时候也是一边参照sass笔记，一边看文档的。看完语法之后我发现两者可以说是很像又可以说有挺大差别，我个人认为sass的功能较less会更加强大一些，但是less优在不需要怎么配置环境。选择哪个应该视情况而定。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"http://yoursite.com/tags/Less/"}]},{"title":"SASS学习笔记","slug":"sass","date":"2018-01-20T12:33:30.000Z","updated":"2018-05-31T13:12:23.117Z","comments":true,"path":"2018/01/20/sass/","link":"","permalink":"http://yoursite.com/2018/01/20/sass/","excerpt":"","text":"SASS学习笔记文件后缀名sass有两种后缀名文件：一种后缀名为sass，不使用大括号和分号；另一种是scss文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。 导入sass的导入( @import)规则和css的有所不同，编译时会将 @import的scss文件合并进来只生成一个css文件。但是如果你在sass文件中导入css文件如 @import &#39;reset.css&#39;，那效果跟普通css导入样式文件一样，导入的css文件不会合并到编译后的文件中，而是以@import方式存在。 所有的sass导入文件都可以忽略后缀名 .scss。 12345//a.scss//-------------------------------body &#123; background: #eee;&#125; 12345@import \"reset.css\";@import \"a\";p&#123; background: #0982c1;&#125; 结果如下： 1234567@import \"reset.css\";body &#123; background: #eee;&#125;p&#123; background: #0982c1;&#125; 变量sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像css属性设置一样），如果值后面加上!default则表示默认值。 普通变量定义之后可以在全局范围内使用。 123456789101112//sass style//-------------------------------$fontSize: 12px;body&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:12px;&#125; 默认变量123456789101112//sass style//-------------------------------$baseLineHeight:1.5 !default;body&#123; line-height: $baseLineHeight; &#125;//css style//-------------------------------body&#123; line-height:1.5;&#125; sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。 12345678910111213//sass style//-------------------------------$baseLineHeight:2;$baseLineHeight:1.5 !default;body&#123; line-height: $baseLineHeight; &#125;//css style//-------------------------------body&#123; line-height:2;&#125; 特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以 #{$variables}形式使用。 1234567891011121314151617181920212223//sass style//-------------------------------$borderDirection:top !default; $baseFontSize:12px !default;$baseLineHeight:1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;//应用于复杂的属性值body&#123; font:#&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style//-------------------------------.border-top&#123; border-top:1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 多值变量多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。 list类型list数据可通过空格，逗号或小括号分隔多个值，可用 nth($var,$index)取值。 定义： 123456//一维数据$px: 5px 10px 20px 30px;//二维数据，相当于js中的二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px); 使用： 12345678910111213141516171819//sass style//-------------------------------$linkColor:#08c #333 !default;//第一个值为默认值，第二个鼠标滑过值a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;//css style//-------------------------------a&#123; color:#08c;&#125;a:hover&#123; color:#333;&#125; map类型map数据以key和value成对出现，其中value又可以是list。格式为： $map: (key1: value1, key2: value2, key3: value3);。可通过map-get($map,$key)取值。 定义： 1$heading: (h1: 2em, h2: 1.5em, h3: 1.2em); 使用： 1234567891011121314151617181920//sass style//-------------------------------$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css style//-------------------------------h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; 全局变量： 在变量值后面加上 !global即为全局变量。 目前变量机制： 在选择器中声明的变量会覆盖外面全局声明的变量。(这也就人们常说的sass没有局部变量) 12345678910111213141516171819//sass style//-------------------------------$fontSize:12px;body&#123; $fontSize: 14px; font-size:$fontSize;&#125;p&#123; font-size:$fontSize;&#125;//css style//-------------------------------body&#123; font-size:14px;&#125;p&#123; font-size:14px;&#125; 启用global之后的机制： 1234567891011121314151617181920212223242526//sass style//-------------------------------$fontSize:12px;$color:#333;body&#123; $fontSize: 14px; $color：#fff !global; font-size:$fontSize; color:$color;&#125;p&#123; font-size:$fontSize; color:$color;&#125;//css style//注意，这个目前还无法使用，所以样式不是真实解析出来的。//-------------------------------body&#123; font-size:14px; color:#fff;&#125;p&#123; font-size:12px; color:#fff;&#125; 嵌套选择器嵌套所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性。 在选择器嵌套中，可以使用 &amp;表示父元素选择器。 1234567891011121314151617181920212223242526272829303132333435363738//sass style//-------------------------------#top_nav&#123; line-height: 40px; text-transform: capitalize; background-color:#333; li&#123; float:left; &#125; a&#123; display: block; padding: 0 10px; color: #fff; &amp;:hover&#123; color:#ddd; &#125; &#125;&#125;//css style//-------------------------------#top_nav&#123; line-height: 40px; text-transform: capitalize; background-color:#333;&#125; #top_nav li&#123; float:left;&#125;#top_nav a&#123; display: block; padding: 0 10px; color: #fff;&#125;#top_nav a:hover&#123; color:#ddd;&#125; 属性嵌套所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。拿个官网的实例看下： 12345678910111213141516171819202122232425//sass style//-------------------------------.fakeshadow &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125;//css style//-------------------------------.fakeshadow &#123; border-style: solid; border-left-width: 4px; border-left-color: #888; border-right-width: 2px; border-right-color: #ccc; &#125; @at-root此语句用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。 普通跳出嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//sass style//-------------------------------//没有跳出.parent-1 &#123; color:#f00; .child &#123; width:100px; &#125;&#125;//单个选择器跳出.parent-2 &#123; color:#f00; @at-root .child &#123; width:200px; &#125;&#125;//多个选择器跳出.parent-3 &#123; background:#f00; @at-root &#123; .child1 &#123; width:300px; &#125; .child2 &#123; width:400px; &#125; &#125;&#125;//css style//-------------------------------.parent-1 &#123; color: #f00;&#125;.parent-1 .child &#123; width: 100px;&#125;.parent-2 &#123; color: #f00;&#125;.child &#123; width: 200px;&#125;.parent-3 &#123; background: #f00;&#125;.child1 &#123; width: 300px;&#125;.child2 &#123; width: 400px;&#125; @at-root (without: ...)默认 @at-root只会跳出选择器嵌套，而不能跳出 @media或 @support，如果要跳出这两种，则需使用 @at-root (without: media)，@at-root (without: support)。这个语法的关键词有四个： all， rule（表示常规css）， media，support。我们默认的 @at-root其实就是 @at-root (without:rule)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//sass style//-------------------------------//跳出父级元素嵌套@media print &#123; .parent1&#123; color:#f00; @at-root .child1 &#123; width:200px; &#125; &#125;&#125;//跳出media嵌套，父级有效@media print &#123; .parent2&#123; color:#f00; @at-root (without: media) &#123; .child2 &#123; width:200px; &#125; &#125; &#125;&#125;//跳出media和父级@media print &#123; .parent3&#123; color:#f00; @at-root (without: all) &#123; .child3 &#123; width:200px; &#125; &#125; &#125;&#125;//sass style//-------------------------------@media print &#123; .parent1 &#123; color: #f00; &#125; .child1 &#123; width: 200px; &#125;&#125;@media print &#123; .parent2 &#123; color: #f00; &#125;&#125;.parent2 .child2 &#123; width: 200px;&#125;@media print &#123; .parent3 &#123; color: #f00; &#125;&#125;.child3 &#123; width: 200px;&#125; @at-root与 &amp;配合使用12345678910111213//sass style//-------------------------------.child&#123; @at-root .parent &amp;&#123; color:#f00; &#125;&#125;//css style//-------------------------------.parent .child &#123; color: #f00;&#125; 应用于@keyframes12345678910111213141516171819202122//sass style//-------------------------------.demo &#123; ... animation: motion 3s infinite; @at-root &#123; @keyframes motion &#123; ... &#125; &#125;&#125;//css style//------------------------------- .demo &#123; ... animation: motion 3s infinite;&#125;@keyframes motion &#123; ...&#125; 混合（mixin）sass中使用 @mixin声明混合（有些类似于编程语言中的函数），可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。 无参数mixin12345678910111213141516//sass style//-------------------------------@mixin center-block &#123; margin-left:auto; margin-right:auto;&#125;.demo&#123; @include center-block;&#125;//css style//-------------------------------.demo&#123; margin-left:auto; margin-right:auto;&#125; 有参数mixin123456789101112131415//sass style//------------------------------- @mixin opacity($opacity:50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125;//css style//-------------------------------.opacity&#123; @include opacity; //参数使用默认值&#125;.opacity-80&#123; @include opacity(80); //传递参数&#125; 多组值参数mixin如果一个参数可以有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点表示，如 $variables...。 12345678910111213141516171819//sass style//------------------------------- //box-shadow可以有多组值，所以在变量参数后面添加...@mixin box-shadow($shadow...) &#123; -webkit-box-shadow:$shadow; box-shadow:$shadow;&#125;.box&#123; border:1px solid #ccc; @include box-shadow(0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125;//css style//-------------------------------.box&#123; border:1px solid #ccc; -webkit-box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3); box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3);&#125; @content@content可以用来解决css3的@media等带来的问题。它可以使 @mixin接受一整块样式，接受的样式从@content开始。（相当于在调用mixin时自定义函数体） 123456789101112131415161718//sass style//------------------------------- @mixin max-screen($res)&#123; @media only screen and ( max-width: $res ) &#123; @content; &#125;&#125;@include max-screen(480px) &#123; body &#123; color: red &#125;&#125;//css style//-------------------------------@media only screen and (max-width: 480px) &#123; body &#123; color: red &#125;&#125; 继承sass中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。 123456789101112131415161718//sass style//-------------------------------h1&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; @extend h1; border-width: 2px;&#125;//css style//-------------------------------h1,.speaker&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; border-width: 2px;&#125; 占位选择器%从sass 3.2.0以后就可以定义占位选择器 %。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了 @extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过 @extend调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//sass style//-------------------------------%ir&#123; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125;%clearfix&#123; @if $lte7 &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; content: \"\"; display: table; font: 0/0 a; &#125; &amp;:after &#123; clear: both; &#125;&#125;#header&#123; h1&#123; @extend %ir; width:300px; &#125;&#125;.ir&#123; @extend %ir;&#125;//css style//-------------------------------#header h1,.ir&#123; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125;#header h1&#123; width:300px;&#125; 继承与混合继承与混合能够完成相同的工作，不过，@mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从3.2.0版本以后，建议传递参数的用 @mixin，而非传递参数类的使用继承 %。 函数sass定义了很多函数可供使用，也可以自己定义函数，以@fuction开始。 1234567891011121314151617181920212223242526272829//sass style//------------------------------- $baseFontSize: 10px !default;$gray: #ccc !defualt; // pixels to rems @function pxToRem($px) &#123; @return $px / $baseFontSize * 1rem;&#125;body&#123; font-size:$baseFontSize; color:lighten($gray,10%);&#125;.test&#123; font-size:pxToRem(16px); color:darken($gray,10%);&#125;//css style//-------------------------------body&#123; font-size:10px; color:#E6E6E6;&#125;.test&#123; font-size:1.6rem; color:#B3B3B3;&#125; 运算sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。 1234567891011$baseFontSize: 14px !default;$baseLineHeight: 1.5 !default;$baseGap: $baseFontSize * $baseLineHeight !default;$halfBaseGap: $baseGap / 2 !default;$samllFontSize: $baseFontSize - 2px !default;//grid $_columns: 12 !default; // Total number of columns$_column-width: 60px !default; // Width of a single column$_gutter: 20px !default; // Width of the gutter$_gridsystem-width: $_columns * ($_column-width + $_gutter); //grid system width 条件判断及循环@if判断@if可一个条件单独使用，也可以和 @else结合多条件使用。 123456789101112131415161718192021222324252627282930313233//sass style//-------------------------------$lte7: true;$type: monster;.ib&#123; display:inline-block; @if $lte7 &#123; *display:inline; *zoom:1; &#125;&#125;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125;//css style//-------------------------------.ib&#123; display:inline-block; *display:inline; *zoom:1;&#125;p &#123; color: green; &#125; 三目判断语法为： if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。 12if(true, 1px, 2px) =&gt; 1pxif(false, 1px, 2px) =&gt; 2px for循环for循环有两种形式，分别为： @for $var from &lt;start&gt; through &lt;end&gt;和 @for $var from &lt;start&gt; to &lt;end&gt;。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。 1234567891011121314151617//sass style//-------------------------------@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;//css style//-------------------------------.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; @each循环语法为： @each $var in &lt;list or map&gt;。其中 $var表示变量，而list和map表示list类型数据和map类型数据。sass 3.3.0新加入了多字段循环和map数据循环。 单个字段list数据循环1234567891011121314151617181920212223//sass style//-------------------------------$animal-list: puma, sea-slug, egret, salamander;@each $animal in $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125;//css style//-------------------------------.puma-icon &#123; background-image: url('/images/puma.png'); &#125;.sea-slug-icon &#123; background-image: url('/images/sea-slug.png'); &#125;.egret-icon &#123; background-image: url('/images/egret.png'); &#125;.salamander-icon &#123; background-image: url('/images/salamander.png'); &#125; 多个字段list数据循环12345678910111213141516171819202122232425262728//sass style//-------------------------------$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125;//css style//-------------------------------.puma-icon &#123; background-image: url('/images/puma.png'); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url('/images/sea-slug.png'); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url('/images/egret.png'); border: 2px solid white; cursor: move; &#125; 多个字段map数据循环1234567891011121314151617181920//sass style//-------------------------------$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css style//-------------------------------h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; 此篇学习笔记参考该文档 。其实我写读书笔记的目的有两个：其一，留下学习的足迹；其二，留待之后需要的时候快速查看。在一边看文档一边写笔记的过程中我都是选择把我认为重要的部分给抄录进来，但是由于我参考的文档很多都是满满的干货，所以经常就变成了整篇整篇的copy…这让我觉得有些尴尬…","categories":[],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"},{"name":"Scss","slug":"Scss","permalink":"http://yoursite.com/tags/Scss/"}]},{"title":"vue2.0中keep-alive实践","slug":"keep-alive","date":"2018-01-19T12:33:30.000Z","updated":"2018-05-31T13:04:52.554Z","comments":true,"path":"2018/01/19/keep-alive/","link":"","permalink":"http://yoursite.com/2018/01/19/keep-alive/","excerpt":"","text":"vue2.0中keep-alive实践vue2.0提供了一个keep-alive组件，用来缓存组件,避免多次加载相应的组件,减少性能消耗。 1.缓存所有页面1234//在router的根页面下&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 2.缓存某些页面1234&lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=\"!$route.meta.keepAlive\"&gt;&lt;/router-view&gt; 然后在router中为需要缓存的页面的meta对象添加keepAlive属性值。 3.keepAlive属性的另一用法除了把keepAlive属性设置为是否缓存的判断条件之外，keepAlive还能够在设置滚动行为时使用： 12345678910scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; if (from.meta.keepAlive) &#123; from.meta.savedPosition = document.body.scrollTop; &#125; return &#123;x:0, y:to.meta.savedPosition || 0&#125; &#125;&#125; 利用以上代码对设置缓存了的页面进行返回后自动滚动。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"SVG学习笔记","slug":"SVG","date":"2018-01-19T12:33:30.000Z","updated":"2018-05-31T13:16:21.878Z","comments":true,"path":"2018/01/19/SVG/","link":"","permalink":"http://yoursite.com/2018/01/19/SVG/","excerpt":"","text":"SVG学习笔记简介SVG使用XML来描述二维图形和绘图程序的语言。 SVG形状SVG在HTML页面SVG 文件可通过以下标签嵌入 HTML 文档：embed、object 或者 iframe。 例如： 1&lt;iframe src=\"circle1.svg\"&gt;&lt;/iframe&gt; 也可以直接在HTML中嵌入SVG代码： 123&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;&lt;/svg&gt; 或者是链接到一个SVG文件： 1&lt;a href=\"circle1.svg\"&gt;View SVG file&lt;/a&gt; SVG矩形-rect例如： 12345&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;rect x=\"50\" y=\"20\" rx=\"20\" ry=\"20\"width=\"300\" height=\"100\" style=\"fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0);fill-opacity:0.1; stroke-opacity:0.9;opacity:0.5\"/&gt;&lt;/svg&gt; x和y属性分别定义矩形距离左侧和顶端的位置 rx和ry用于使矩形产生圆角 width和height分别用于定义矩形宽度和高度 style属性用于定义CSS样式 fill属性定义填充颜色 stroke-width定义边框的宽度 stroke属性定义边框的颜色 fill-opacity定义背景颜色的透明度 stroke-opacity定义边框的透明度 opacity定义整个图像的透明度 SVG圆形-circle例如： 1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; cx和cy属性定义圆点的圆心坐标。如果省略cx和cy，圆的中心会被设置为(0, 0) r属性用于定义半径大小 fill属性定义背景颜色 SVG椭圆形-ellipse例如： 1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;ellipse cx=\"300\" cy=\"80\" rx=\"100\" ry=\"50\" style=\"fill:yellow;stroke:purple;stroke-width:2\"/&gt;&lt;/svg&gt; rx属性定义水平半径 ry属性定义垂直半径 SVG直线-line例如： 1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;line x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\" style=\"stroke:rgb(255,0,0);stroke-width:2\"/&gt;&lt;/svg&gt; x1与y1定义起始点 x2与y2定义终点 SVG多边形-polygon例如： 1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polygon points=\"100,10 40,180 190,60 10,60 160,180\" style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;\" /&gt;&lt;/svg&gt; points 属性定义多边形每个角的坐标 style中的fill-rule属性用于定义使用哪一种算法去判别某个点是否在图形内部，共有三个值（nonzero | evenodd | inherit） SVG曲线-polyline例如： 1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polyline points=\"20,20 40,25 60,40 80,120 120,140 200,180\" style=\"fill:none;stroke:black;stroke-width:3\" /&gt;&lt;/svg&gt; 注意：fill属性需要设为none，否则曲线外有部分将被填充颜色 SVG路径-pathpath属性支持的指令： M = moveto(M X,Y) ：将画笔移动到指定的坐标位置 L = lineto(L X,Y) ：画直线到指定的坐标位置 H = horizontal lineto(H X)：画水平线到指定的X坐标位置 V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置 C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线 S = smooth curveto(S X2,Y2,ENDX,ENDY) Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线 T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射 A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线 Z = closepath()：关闭路径 例如： 12345678910111213141516171819&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;path d=&quot;M153 334C153 334 151 334 151 334C151 339 153 344 156 344C164 344 171 339 171 334C171 322 164 314 156 314C142 314 131 322 131 334C131 350 142 364 156 364C175 364 191 350 191 334C191 311 175 294 156 294C131 294 111 311 111 334C111 361 131 384 156 384C186 384 211 361 211 334C211 300 186 274 156 274&quot;style=&quot;fill:white;stroke:red;stroke-width:2&quot;/&gt;&lt;/svg&gt; 其中d属性实际上是一个字符串，包含了一系列路径描述 注意：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 SVG文字-text例如： 123&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;text x=\"0\" y=\"15\" fill=\"red\"&gt;I love SVG&lt;/text&gt;&lt;/svg&gt; 123456789&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;defs&gt; &lt;path id=\"path1\" d=\"M75,20 a1,1 0 0,0 100,0\" /&gt; &lt;/defs&gt; &lt;text x=\"10\" y=\"100\" style=\"fill:red;\"&gt; &lt;textPath xlink:href=\"#path1\"&gt;I love SVG I love SVG&lt;/textPath&gt; &lt;/text&gt;&lt;/svg&gt; 其余常用属性 defs ：此元素用于预定义一个元素使其能够在SVG图像中重复使用 g ：该元素用于包围组织一些SVG元素，使得可以整体一起操作 注意：在defs元素中定义的图形不会直接显示在SVG图像上。要显示它们需要使用use元素来引入它们 symbol ：该元素兼具g的分组功能和defs初始不可见的特性。symbol能够创建自己的视窗，所以能够应用viewBox（viewBox=&quot;x, y, width, height&quot; // x:左上角横坐标，y:左上角纵坐标，width:宽度，height:高度）和preserveAspectRatio属性 此篇笔记是关于SVG的形状初步学习，如果之后有需要，我会继续了解然后完善这篇笔记。","categories":[],"tags":[{"name":"SVG","slug":"SVG","permalink":"http://yoursite.com/tags/SVG/"}]},{"title":"CSS中的层叠","slug":"css中的层叠","date":"2018-01-12T12:33:30.000Z","updated":"2018-06-19T09:20:20.937Z","comments":true,"path":"2018/01/12/css中的层叠/","link":"","permalink":"http://yoursite.com/2018/01/12/css中的层叠/","excerpt":"","text":"CSS中的层叠css的中文全称为层叠样式表，这暗示了层叠的重要性。 我们常常遇到，两个选择器同时选中同一个元素，并且它们提供的样式造成了冲突的情况。那么此时，应该应用哪个样式呢？ 我们可以使用专用性来衡量。 专用性专用性的评判标准如下： 如果该声明是在style属性中（即内联样式），那么此声明增加1000分； 若选择器中每包含一个id选择器，则此声明增加100分； 如果选择器每包含一个类选择器、属性选择器或者伪类，就给该声明增加10分； 若选择器中每包含一个元素选择器或伪元素，那么此声明就增加1分； 以下为示例： 选择器 千位 百位 十位 个位 合计值 h1 0 0 0 1 0001 #important 0 1 0 0 0100 h1 + p::first-letter 0 0 0 3 0003 li &gt; a[href*=&quot;zh-CN&quot;] &gt; .inline-warning 0 0 2 2 0022 没有选择器, 规则在一个元素的style属性里 1 0 0 0 1000 注意：如果一个属性后边跟着!important ，那么说明该属性值具有最优先权。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"webpack异步加载原理","slug":"webpackAsync","date":"2017-12-27T12:33:30.000Z","updated":"2018-05-31T13:19:36.391Z","comments":true,"path":"2017/12/27/webpackAsync/","link":"","permalink":"http://yoursite.com/2017/12/27/webpackAsync/","excerpt":"","text":"webpack异步加载原理​ webpack ensure是什么？有人称它为异步加载，也有人称它为代码切割。假如一个场景：某个应用的首页上有个按钮，点击此按钮将会打开某个地图（需要用到百度地图的js文件），而百度地图的js文件是非常大的，如果一开始就把它打包进首页的话，就会使得用户打开首页的时间变得比较长。 ​ 在这种情况下，有一种解决方法是，先不打包该js文件，而是在需要用到时（本例中点击按钮时）才去加载。这就可以利用webpack中的webpack ensure 来实现。以下为示例代码： 12345678var sync = require('syncdemo.js') //下面ensure里面也用到mapBtn.click(function() &#123; require.ensure([], function() &#123; var baidumap = require('./baidumap.js') //baidumap.js放在我们当前目录下 var sync = require('syncdemo.js') //这个不会独立出去，因为它已经加载到模块缓存中了 &#125;)&#125;) ​ 其中syncdemo.js 是在webpack ensure外加载的，所以它其实是同步加载，之后的再次引入是使用的缓存。webpack ensure 有两个参数，第二个参数就是回调函数，使用它来请求模块。第一个参数[] 中存放的是这个webpack ensure 加载所依赖的模块，注意：依赖模块和异步模块将会打包到同一个js文件中，这样可能就会导致重复打包的问题。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]}]}